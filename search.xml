<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聚类算法之层次聚类]]></title>
    <url>%2Fposts%2Faedf7706%2F</url>
    <content type="text"><![CDATA[层次聚类(Hierarchical Clustering)是聚类算法的一种，通过计算不同类别的相似度类创建一个有层次的嵌套的树。 层次聚类怎么算]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类算法之DBSCAN聚类]]></title>
    <url>%2Fposts%2Fae704b86%2F</url>
    <content type="text"><![CDATA[DBSCAN （Density-Based Spatial Clustering of Applications with Noise） 是一种基于密度的聚类算法，基于密度的聚类寻找被低密度区域分离的高密度区域。常用于异常值或者离群点检测。 DBSCAN 怎么算当某个点的密度达到算法设定的阈值，则这个点称为核心对象。（即r领域内点的数量小于minPts），其中领域的距离阈值为用户设定值。 若某点p在q的r领域内，且q是核心点，则p-q直接密度可达。若有一个点的序列q0、q1、q2…qK，对任意的qi-qi+1是直接密度可达的，则称q0到qK密度可达。称为密度的传播。 当一个非核心点不能发展下线，则称该点为边界点。若某一点，从任一核心地点出发都是密度不可达的，则称该点为噪声点 DBSCAN 聚类算法实现如下图： 当出现奇葩数据时，K-Means 无法正常聚类，而 DBSCAN 完全无问题 优点： 与K-Means相比，不需要手动确定簇的个数K，但需要确定邻域r和密度阈值minPts 能发现任意形状的簇 能有效处理噪声点（邻域r和密度阈值minPts参数的设置可以影响噪声点） 缺点： 当数据量大时，处理速度慢，消耗大 当空间聚类的密度不均匀、聚类间距差相差很大时参数密度阈值minPts和邻域r参数选取困难 对于高维数据，容易产生“维数灾难”（聚类算法基于欧式距离的通病） DBSCAN 聚类 Python 实现# coding=utf-8 &quot;&quot;&quot; Created on 2019/10/12 11:42 @author: EwdAger &quot;&quot;&quot; import numpy as np from sklearn.cluster import DBSCAN from sklearn import metrics from sklearn.datasets.samples_generator import make_blobs from sklearn.preprocessing import StandardScaler import matplotlib.pyplot as plt centers = [[1, 1], [-1, -1], [1, -1]] # 生成聚类中心点 X, labels_true = make_blobs(n_samples=750, centers=centers, cluster_std=0.4,random_state=0) # 生成样本数据集 X = StandardScaler().fit_transform(X) # StandardScaler 标准化处理。且是针对每一个特征维度来做的，而不是针对样本。 # 调用密度聚类 DBSCAN db = DBSCAN(eps=0.3, min_samples=10).fit(X) # print(db.labels_) # db.labels_为所有样本的聚类索引，没有聚类索引为-1 # print(db.core_sample_indices_) # 所有核心样本的索引 core_samples_mask = np.zeros_like(db.labels_, dtype=bool) # 设置一个样本个数长度的全false向量 core_samples_mask[db.core_sample_indices_] = True #将核心样本部分设置为true labels = db.labels_ n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0) # 获取聚类个数。（聚类结果中-1表示没有聚类为离散点） # 模型评估 print(&#39;估计的聚类个数为: %d&#39; % n_clusters_) print(&quot;同质性: %0.3f&quot; % metrics.homogeneity_score(labels_true, labels)) # 每个群集只包含单个类的成员。 print(&quot;完整性: %0.3f&quot; % metrics.completeness_score(labels_true, labels)) # 给定类的所有成员都分配给同一个群集。 print(&quot;V-measure: %0.3f&quot; % metrics.v_measure_score(labels_true, labels)) # 同质性和完整性的调和平均 print(&quot;调整兰德指数: %0.3f&quot; % metrics.adjusted_rand_score(labels_true, labels)) print(&quot;调整互信息: %0.3f&quot; % metrics.adjusted_mutual_info_score(labels_true, labels)) print(&quot;轮廓系数: %0.3f&quot; % metrics.silhouette_score(X, labels)) # Plot result unique_labels = set(labels) colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_labels))] plt.figure(figsize=(10,6)) for k, col in zip(unique_labels, colors): if k == -1: # 聚类结果为-1的样本为离散点 # 使用黑色绘制离散点 col = [0, 0, 0, 1] class_member_mask = (labels == k) # 将所有属于该聚类的样本位置置为true xy = X[class_member_mask &amp; core_samples_mask] # 将所有属于该类的核心样本取出，使用大图标绘制 plt.plot(xy[:, 0], xy[:, 1], &#39;o&#39;, markerfacecolor=tuple(col), markeredgecolor=&#39;k&#39;, markersize=14) xy = X[class_member_mask &amp; ~core_samples_mask] # 将所有属于该类的非核心样本取出，使用小图标绘制 plt.plot(xy[:, 0], xy[:, 1], &#39;o&#39;, markerfacecolor=tuple(col), markeredgecolor=&#39;k&#39;, markersize=6) plt.title(&#39;Estimated number of clusters: %d&#39; % n_clusters_) plt.show() 输出 估计的聚类个数为: 3 同质性: 0.953 完整性: 0.883 V-measure: 0.917 调整兰德指数: 0.952 调整互信息: 0.883 轮廓系数: 0.626]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python异常处理traceback和exc_info]]></title>
    <url>%2Fposts%2F1a6c337e%2F</url>
    <content type="text"><![CDATA[开发过程中一般都会使用traceback将捕获到的异常打印出来。 import traceback def fake_exception(): 1 / 0 def catch_exception(): try: fake_exception() except: traceback.print_exc() catch_exception() 结果 Traceback (most recent call last): File &quot;.\test.py&quot;, line 9, in catch_exception fake_exception() File &quot;.\test.py&quot;, line 5, in fake_exception 1 / 0 ZeroDivisionError: integer division or modulo by zero 事实上，traceback里的所有信息都是从exc_info里面获取的。 traceback.print_exc([limit[, file]]) In fact, it uses sys.exc_info() to retrieve the same information in a thread-safe way instead of using the deprecated variables. 那么我们再来看一下exc_info()这个方法。https://docs.python.org/2/library/sys.html?highlight=sys#module-sys该方法返回三个值：type, value, traceback. type (异常类别) get the exception type of the exception being handled (a class object) value (异常说明，可带参数) get the exception parameter (a class instance) traceback (traceback对象，包含更丰富的信息) get a traceback object which encapsulates the call stack at the point where the exception originally occurred (a traceback object) 其中traceback中还包含了更为丰富的信息，比如文件名，行号等等。如果觉得系统默认的traceback打印格式不好看的话，可以利用exc_info的返回值自定义格式。 import sys def fake_exception(): 1 / 0 def catch_exception(): try: fake_exception() except: e_type, e_value, e_traceback = sys.exc_info() print &quot;type ==&gt; %s&quot; % (e_type.__name__) print &quot;value ==&gt; %s&quot; %(e_value) print &quot;traceback ==&gt; file name: %s&quot; %(e_traceback.tb_frame.f_code.co_filename) print &quot;traceback ==&gt; line no: %s&quot; %(e_traceback.tb_lineno) print &quot;traceback ==&gt; function name: %s&quot; %(e_traceback.tb_frame.f_code.co_name) catch_exception() 结果显示 type ==&gt; typename: ZeroDivisionError value ==&gt; message: integer division or modulo by zero traceback ==&gt; fielname: .\test.py traceback ==&gt; lineno: 8 traceback ==&gt; name: catch_exception 原文地址]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python读取Excel文件sheet名性能优化]]></title>
    <url>%2Fposts%2F6b56ef63%2F</url>
    <content type="text"><![CDATA[原始版本直接使用pandas读取整个Excel文件，再从中取列名。这种场景对于小的Excel文件还适用，但数据量上升到10M+时，取个sheet name要26s之久。几乎无法忍受。 data = pandas.ExcelFile(file_url) names = data.sheet_names 优化查阅资料可知.xlsx文件是一个压缩格式的文件，可以直接通过zipfile读到sheet name等相关信息。所以写如下函数直接取sheet name def get_sheet_details(file_path): sheets = [] file_name = os.path.splitext(os.path.split(file_path)[-1])[0] # 用文件名创建一个临时目录 directory_to_extract_to = file_name os.mkdir(directory_to_extract_to) # 提取xlsx文件，因为它只是一个zip文件 zip_ref = zipfile.ZipFile(file_path, &#39;r&#39;) zip_ref.extractall(directory_to_extract_to) zip_ref.close() # 建立一个临时的workbook文件 path_to_workbook = os.path.join(directory_to_extract_to, &#39;xl&#39;, &#39;workbook.xml&#39;) with open(path_to_workbook, &#39;r&#39;) as f: xml = f.read() dictionary = xmltodict.parse(xml) # 多个sheet if isinstance(dictionary[&#39;workbook&#39;][&#39;sheets&#39;][&#39;sheet&#39;], list): for sheet in dictionary[&#39;workbook&#39;][&#39;sheets&#39;][&#39;sheet&#39;]: # 有些版本的sheet是@name有些是@sheetId if sheet[&quot;@name&quot;]: meta_sheet = sheet[&quot;@name&quot;] else: meta_sheet = sheet[&quot;@sheetId&quot;] sheets.append(meta_sheet) # 单个sheet else: sheet_dict = dictionary[&#39;workbook&#39;][&#39;sheets&#39;][&#39;sheet&#39;] if sheet_dict[&quot;@name&quot;]: sheets.append(sheet_dict[&quot;@name&quot;]) else: sheets.append(sheet_dict[&quot;@sheetId&quot;]) shutil.rmtree(directory_to_extract_to) f.close() return sheets 使用该种方法，读14M的文件仅需0.04s。（数据都没加载，当然和文件大小无关啦） 一个问题该函数只能针对.xlsx文件进行解析，而低版本的.xls文件就直接报错了，因为.xls是一个二进制文件而不是压缩文件。所以要以另一种方式去解析sheet name。经过查阅相关资料，发现xlrd.open_workbook的on_demand=True针对低版本的Excel文件可以只取列名而不加载数据。 if file_url[-3:] == &#39;xls&#39;: names = xlrd.open_workbook(file_url, on_demand=True).sheet_names() else: names = get_sheet_details(file_url)]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类算法之K-Means(K均值)聚类]]></title>
    <url>%2Fposts%2Fdea808f4%2F</url>
    <content type="text"><![CDATA[聚类与分类的区别分类： 类别是已知的，通过对已知分类的数据进行训练和学习，找到不同类的特征再对未分类的数据进行分类，属于监督学习。 聚类： 事先不知道数据会分为几类，通过聚类分析将数据聚合成几个群体。聚类不需要对数据进行训练和学习。属于无监督学习。 数据输入有标签则为监督学习，否则为无监督学习 k-means 聚类怎么算 首先输入 k 的值，即希望通过聚类得到 k 个分组； 从数据集中随机选取 k 个数据点作为初始质心 对数据中每一个点计算与每一个质心的距离，离哪个质心近，就分为哪一类 基于当前分好的类，重新计算类中的所有向量的平均值，确定新的质心 重复3、4步 直到新的质心与老的质心的距离小于某一个设定的阈值，可以认为达到预期，算法终止。 具体步骤如下图： k-means 聚类 Python 实现import numpy as np from sklearn.cluster import KMeans data = np.random.rand(100, 3) #生成一个随机数据，样本大小为100, 特征数为3 #假如我要构造一个聚类数为3的聚类器 estimator = KMeans(n_clusters=3)#构造聚类器 estimator.fit(data)#聚类 label_pred = estimator.labels_ #获取聚类标签 centroids = estimator.cluster_centers_ #获取聚类中心 inertia = estimator.inertia_ # 获取聚类准则的总和 主函数 KMeans 参数解释sklearn.cluster.KMeans(n_clusters=8, init=&#39;k-means++&#39;, n_init=10, max_iter=300, tol=0.0001, precompute_distances=&#39;auto&#39;, verbose=0, random_state=None, copy_x=True, n_jobs=1, algorithm=&#39;auto&#39; ) n_clusters:簇的个数，即你想聚成几类 init: 初始簇中心的获取方法 n_init: 获取初始簇中心的更迭次数，为了弥补初始质心的影响，算法默认会初始10次质心，实现算法，然后返回最好的结果。 max_iter: 最大迭代次数（因为kmeans算法的实现需要迭代） tol: 容忍度，即kmeans运行准则收敛的条件 precompute_distances：是否需要提前计算距离，这个参数会在空间和时间之间做权衡，如果是True 会把整个距离矩阵都放到内存中，auto 会默认在数据样本大于featurs*samples 的数量大于12e6 的时候False,False 时核心实现的方法是利用Cpython 来实现的 verbose: 冗长模式（不太懂是啥意思，反正一般不去改默认值） random_state: 随机生成簇中心的状态条件。 copy_x: 对是否修改数据的一个标记，如果True，即复制了就不会修改数据。bool 在scikit-learn 很多接口中都会有这个参数的，就是是否对输入数据继续copy 操作，以便不修改用户的输入数据。这个要理解Python 的内存机制才会比较清楚。 n_jobs: 并行设置 algorithm: kmeans的实现算法，有：auto, full, elkan, 其中 full表示用EM方式实现 具体 Python 实现# coding=utf-8 &quot;&quot;&quot; Created on 2019/10/9 16:31 @author: EwdAger &quot;&quot;&quot; import numpy as np import pandas as pd from sklearn.cluster import KMeans import matplotlib.pyplot as plt data = pd.read_csv(r&quot;F:\MachineLearning\Kmeans\data\testSet.txt&quot;, sep=&#39;\t&#39;, header=0, dtype=str, na_filter=False).astype(np.float) k = 4 clt = KMeans(n_clusters=k) clt.fit(data) cents = clt.cluster_centers_ # 获取聚类中心 labels = clt.labels_ # 获取聚类标签 colors = [&#39;b&#39;, &#39;g&#39;, &#39;r&#39;, &#39;k&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;#e24fff&#39;, &#39;#524C90&#39;, &#39;#845868&#39;] # 画图 for i in range(k): # 获取i组数据的index index = np.nonzero(labels == i)[0] x0 = data.iloc[data.index.isin(index), 0].tolist() x1 = data.iloc[data.index.isin(index), 1].tolist() y_i = i # 给第i组数据涂上颜色，进行分组 for j in range(len(x0)): plt.text(x0[j], x1[j], str(y_i), color=colors[i], fontdict={&#39;weight&#39;: &#39;bold&#39;, &#39;size&#39;: 6}) # 绘制该组质心 plt.scatter(cents[i, 0], cents[i, 1], marker=&#39;x&#39;, color=colors[i], linewidths=7) plt.axis([-7, 7, -7, 7]) plt.show() 结果如下：]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习速查笔记-Numpy篇]]></title>
    <url>%2Fposts%2Fec7adaa1%2F</url>
    <content type="text"><![CDATA[numpynp.unique(A)对于一维数组或者列表，unique函数去除其中重复的元素，并按元素由大到小返回一个新的无元素重复的元组或者列表 A = [1,1,2,3,4,4,5,5,6] a = np.unique(A) print(a) # [1 2 3 4 5 6] np.random.rand（x…）生成随机的指定维度的列表 a=np.random.rand(4) for var in range(10): print(a) a = np.random.rand(4) 结果： [0.21849839 0.06253395 0.10794774 0.88207845] [0.38262448 0.93590044 0.01358229 0.67018295] [0.52202392 0.55000451 0.8633613 0.64067578] [0.3782018 0.74330012 0.33034715 0.74607596] [0.07583301 0.71505934 0.66028763 0.54293845] np.random.uniform(low,high,size)参考原文 从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high. low: 采样下界，float类型，默认值为0； high: 采样上界，float类型，默认值为1； size: 输出样本数目，为int或元组(tuple)类型，例如，size=(m,n,k), 则输出mnk个样本，缺省时输出1个值。 返回值：ndarray类型，其形状和参数size中描述一致。 类似uniform,还有以下随机数产生函数： a. randint: 原型：numpy.random.randint(low, high=None, size=None, dtype=&#39;l&#39;)，产生随机整数； b. random_integers: 原型： numpy.random.random_integers(low, high=None, size=None)，在闭区间上产生随机整数； c. random_sample: 原型： numpy.random.random_sample(size=None)，在[0.0,1.0)上随机采样； d. random: 原型： numpy.random.random(size=None)，和random_sample一样，是random_sample的别名； e. rand: 原型： numpy.random.rand(d0, d1, ..., dn)，产生d0 - d1 - … - dn形状的在[0,1)上均匀分布的float型数。 f. randn: 原型：numpy.random.randn（d0,d1,...,dn),产生d0 - d1 - … - dn形状的标准正态分布的float型数。 np.random.seed(x…)当我们设置相同的seed，每次生成的随机数相同，如果不指定seed，就是真随机数 np.random.seed(0) a=np.random.rand(4) for var in range(5): print(a) np.random.seed(0) a = np.random.rand(4) 结果： [0.5488135 0.71518937 0.60276338 0.54488318] [0.5488135 0.71518937 0.60276338 0.54488318] [0.5488135 0.71518937 0.60276338 0.54488318] [0.5488135 0.71518937 0.60276338 0.54488318] [0.5488135 0.71518937 0.60276338 0.54488318] np.random.permutation()返回一个随机排列 [3 9 1 2 8 4 7 6 0 5] numpy.random.choicenumpy.random.choice(a, size=None, replace=True, p=None) 参数: a：一维数组或者int型变量，如果是数组，就按照里面的范围来进行采样，如果是单个变量，则采用np.arange(a)的形式 size : int 或者 tuple of ints, 可选参数 (决定了输出的shape. 如果给定的是, (m, n, k), 那么 m n k 个采样点将会被采样. 默认为零，也就是只有一个采样点会被采样回来。) replace : 布尔参数，可选参数 (决定采样中是否有重复值) p :一维数组参数，可选参数 (对应着a中每个采样点的概率分布，如果没有标出，则使用标准分布。) 返回值: samples : single item or ndarray np.argsortargsort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)argsort函数返回的是数组值从小到大的索引值的列表。 x = np.array([1, 4, 3, -1, 6, 9]) np.argsort(x) # 输出定义为 y=array([3, 0, 2, 1, 4, 5]) # 我们发现argsort()函数是将x中的元素从小到大排列，提取其对应的index，然后输出 np.argsort()[num] 当num&gt;=0时，np.argsort()[num]就可以理解为y[num]; 当num&lt;0时，np.argsort()[num]就是把数组y的元素反向输出，例如np.argsort()[-1]即输出x中最大值对应的index，np.argsort()[-2]即输出x中第二大值对应的index shape（属性）返回元组，为对象的形状，若为一维DataFrame或Series则元组第二项维空(其实就是只有一个元素的元组)例(5,) reshpae（方法）是数组对象中的方法，用于改变数组的形状,也可以用来改变数据的维度，如1D-&gt;2D。 reshape函数生成的新数组和原始数组公用一个内存，也就是说，不管是改变新数组还是原始数组的元素，另一个数组也会随之改变： 关于Python中reshape函数参数-1的意思？ 根据前值（或后值）来推测形状（可以用来偷懒） In [30]: obj = np.arange(25) In [31]: obj.reshape(-1,5) Out[31]: array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]) numpy.mean()计算矩阵均值 a = np.array([[1, 2], [3, 4]]) np.mean(a) # 将上面二维矩阵的每个元素相加除以元素个数（求平均数） # 2.5 np.mean(a, axis=0) # axis=0，计算每一列的均值 # array([ 2., 3.]) np.mean(a, axis=1) # 计算每一行的均值 # array([ 1.5, 3.5]) np.var（）计算方差 In [32]: np.var([6, 8, 10, 14, 18], ddof=1) # ddof 参数是贝塞尔矫正系数（无偏估计），求方差 Out[32]: 23.2 np.cov（）计算协方差 &gt;&gt;&gt; X=np.array([[1 ,5 ,6] ,[4 ,3 ,9 ],[ 4 ,2 ,9],[ 4 ,7 ,2]]) &gt;&gt;&gt; np.cov(X) array([[ 7. , 4.5 , 4. , -0.5 ], [ 4.5 , 10.33333333, 11.5 , -7.16666667], [ 4. , 11.5 , 13. , -8.5 ], [ -0.5 , -7.16666667, -8.5 , 6.33333333]]) np.linalg.lstsq（）（本例返回两个相关因子和一个截距）用最小二乘法拟合数据得到一个形如y = mx + c的线性方程 In [34]: x = [[1,6,2],[1,8,1],[1,10,0],[1,14,2],[1,18,0]] In [35]: y = [[7], [9], [13], [17.5], [18]] In [36]: np.linalg.lstsq(x, y)[0] C:\Users\dell\AppData\Local\Programs\Python\Python36\Scripts\ipython:1: FutureWarning: `rcond` parameter will change to the default of machine precision times ``max(M, N)`` where M and N are the input matrix dimensions. To use the future default and silence this warning we advise to pass `rcond=None`, to keep using the old, explicitly pass `rcond=-1`. Out[36]: array([[1.1875 ], [1.01041667], [0.39583333]]) numpy.linspace()numpy.linspace(start,stop,num=50,endpoint=True,retstep=False，dtype=None) linspace函数可以生成50个元素的等差数列。而前两个参数分别是数列的开头与结尾。第三个参数，可以制定数列的元素个数 In [40]: np.linspace(1,50) Out[40]: array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31., 32., 33., 34., 35., 36., 37., 38., 39., 40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50.]) np.logspace()numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)[source]logspac用于创建等比数列，默认以10为底，元素个数是num [45]: np.logspace(0, 9, 10, base=2) Out[45]: array([ 1., 2., 4., 8., 16., 32., 64., 128., 256., 512.]) min（）返回最小值，可指定axis In [60]: c = np.array([[1,5,3],[4,2,6]]) In [61]: c.min() Out[61]: 1 In [62]: c.min(axis=0) Out[62]: array([1, 2, 3]) In [63]: c.min(axis=1) Out[63]: array([1, 2]) np.hstack() &amp; np.vstack()水平(按列顺序)把数组给堆叠起来垂直（按列顺序）把数组给堆叠起来 In [66]: arr1 = np.array([1, 2, 3]) In [67]: arr2 = np.array([4, 5, 6]) In [68]: np.hstack((arr1, arr2)) Out[68]: array([1, 2, 3, 4, 5, 6]) In [69]: np.vstack((arr1, arr2)) Out[69]: array([[1, 2, 3], [4, 5, 6]]) numpy.where（）numpy.where(condition[, x, y]) 这里x,y是可选参数，condition是条件，这三个输入参数都是array_like的形式；而且三者的维度相同 当conditon的某个位置的为true时，输出x的对应位置的元素，否则选择y对应位置的元素； 如果只有参数condition，则函数返回为true的元素的坐标位置信息； numpy.where()分两种调用方式： 三个参数np.where(cond,x,y)：满足条件（cond）输出x，不满足输出y&gt;&gt;&gt; aa = np.arange(10) &gt;&gt;&gt; np.where(aa,1,-1) array([-1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # 0为False，所以第一个输出-1 一个参数np.where(arry)：输出arry中‘真’值的坐标(‘真’也可以理解为非零)&gt;&gt;&gt; a = np.array([2,4,6,8,10]) &gt;&gt;&gt; np.where(a &gt; 5) # 返回索引 (array([2, 3, 4]),)]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>数据分析</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Cython加密打包python项目]]></title>
    <url>%2Fposts%2Fa2a2ab6a%2F</url>
    <content type="text"><![CDATA[使用将下述代码保存为setup.py至需打包项目根目录，安装cython后执行python setup.py即可打包。 import sys, os, shutil, time from distutils.core import setup from Cython.Build import cythonize start_time = time.time() curr_dir = os.path.abspath(&#39;.&#39;) parent_path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;&quot; setup_file = __file__.replace(&#39;/&#39;, &#39;\\&#39;) build_dir = &quot;build&quot; build_tmp_dir = build_dir + &quot;/temp&quot; s = &quot;# cython: language_level=3&quot; def get_py(base_path=os.path.abspath(&#39;.&#39;), parent_path=&#39;&#39;, name = &#39;&#39;, excepts=(), copyOther=False, delC = False): &quot;&quot;&quot; 获取py文件的路径 :param base_path: 根路径 :param parent_path: 父路径 :param excepts: 排除文件 :return: py文件的迭代器 &quot;&quot;&quot; full_path = os.path.join(base_path, parent_path, name) for filename in os.listdir(full_path): full_filename = os.path.join(full_path, filename) if os.path.isdir(full_filename) and filename != build_dir and not filename.startswith(&#39;.&#39;): for f in get_py(base_path, os.path.join(parent_path, name), filename, excepts, copyOther, delC): yield f elif os.path.isfile(full_filename): ext = os.path.splitext(filename)[1] if ext == &quot;.c&quot;: if delC and os.stat(full_filename).st_mtime &gt; start_time: os.remove(full_filename) elif full_filename not in excepts and os.path.splitext(filename)[1] not in (&#39;.pyc&#39;, &#39;.pyx&#39;): if os.path.splitext(filename)[1] in (&#39;.py&#39;, &#39;.pyx&#39;) and not filename.startswith(&#39;__&#39;): path = os.path.join(parent_path, name, filename) yield path else: pass def pack_pyd(): # 获取py列表 module_list = list(get_py(base_path=curr_dir, parent_path=parent_path, excepts=(setup_file,))) try: setup( ext_modules=cythonize(module_list, compiler_directives={&#39;language_level&#39;: &quot;3&quot;}), script_args=[&quot;build_ext&quot;, &quot;-b&quot;, build_dir, &quot;-t&quot;, build_tmp_dir], ) except Exception as ex: print(&quot;error! &quot;, str(ex)) else: module_list = list(get_py(base_path=curr_dir, parent_path=parent_path, excepts=(setup_file,), copyOther=True)) module_list = list(get_py(base_path=curr_dir, parent_path=parent_path, excepts=(setup_file,), delC=True)) if os.path.exists(build_tmp_dir): shutil.rmtree(build_tmp_dir) print(&quot;complate! time:&quot;, time.time() - start_time, &#39;s&#39;) def delete_c(path=&#39;.&#39;, excepts=(setup_file,)): &#39;&#39;&#39; 删除编译过程中生成的.c文件 :param path: :param excepts: :return: &#39;&#39;&#39; dirs = os.listdir(path) for dir in dirs: new_dir = os.path.join(path, dir) if os.path.isfile(new_dir): ext = os.path.splitext(new_dir)[1] if ext == &#39;.c&#39;: os.remove(new_dir) elif os.path.isdir(new_dir): delete_c(new_dir) if __name__ == &#39;__main__&#39;: try: pack_pyd() except Exception as e: print(str(e)) finally: delete_c() 常见问题 出现Unable to find vcvarsall.bat错误 需安装对应版本VC++ 下载地址 其他文件都能打包，某一文件迷之无法打包 检查文件名是否包含非法字符（比如-） Linux下打包失败或卡住不动 检查是否安装依赖yum install python-devel gcc,如果确定安装依赖，可以稍微等一等，Linux内存不足编译稍大型文件会要很长时间 打包后出现无法调用某模块 检查对应文件是否循环import(如A文件首行调用B，B首行调用A，默认解释器执行不会出错，编译后会出错) 打包后路径出现问题 在每个需要打包的文件夹中加入空的__init__.py文件用于判断路径，如果有非空的__init__.py文件，记得打包后复制进对应文件夹 尚未解决的问题 __init__.py判断路径打包和import相对路径绝对路径复用，某些情况下打包后会出现无法定位某些模块的奇怪问题]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>cython</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas笔记-进阶篇]]></title>
    <url>%2Fposts%2Fa61b68c3%2F</url>
    <content type="text"><![CDATA[汇总和计算描述统计panda对象拥有一组常用的数学和统计方法，他们大部分都属于简约统计，NA值会自动被排除，除非通过skipna=False禁用 In [78]: df Out[78]: one two a 1.40 NaN b 7.10 -4.5 c NaN NaN d 0.75 -1.3 In [79]: df.sum() Out[79]: one 9.25 two -5.80 dtype: float64 In [80]: df.sum(axis=1) Out[80]: a 1.40 b 2.60 c 0.00 d -0.55 dtype: float64 In [81]: df.sum(skipna=False, axis=1) Out[81]: a NaN b 2.60 c NaN d -0.55 dtype: float64 简约方法选项 选项 说明 axis 简约的轴 skipna 排除缺失值，默认True level 如果轴是层次化索引的，则根据level分组简约 描述和汇总统计 方法 说明 count 非NA值的数量 describe 针对Series或各DataFrame列计算汇总统计 min、max 计算最小值和最大值 argmin、argmax 计算能够获取到最小值和最大值的索引位置（整数） idxmin、idxmax 计算能够获取到最小值和最大值的索引值 quantile 计算样本的分位数（0到1） sum 值的总和 mean 值的平均数 median 值的算术中位数（50%分位数） mad 根据平均值计算平均绝对离差 var 样本值的方差 std 样本值的标准差 skew 样本值的偏度（三阶矩） kurt 样本值的峰度（四阶矩） cumsum 样本值的累计和 cummin、cummax 样本值的累计最大值和累计最小值 cumprod 样本值的累计积 diff 计算一阶差分（对时间序列很有用） pct_change 计算百分数变化 相关系数与协方差corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。cov方法用于计算协方差。 In [18]: returns.cov() Out[18]: AAPL IBM MSFT GOOG AAPL 0.001030 0.000254 0.000309 0.000303 IBM 0.000254 0.000369 0.000216 0.000142 MSFT 0.000309 0.000216 0.000516 0.000205 GOOG 0.000303 0.000142 0.000205 0.000580 In [19]: returns.corr() Out[19]: AAPL IBM MSFT GOOG AAPL 1.000000 0.412392 0.423598 0.470676 IBM 0.412392 1.000000 0.494358 0.390689 MSFT 0.423598 0.494358 1.000000 0.443586 GOOG 0.470676 0.390689 0.443586 1.000000 看不太懂。。。留个笔记P146 唯一值、值计数以及成员资格unique方法可以得到Series中唯一值的数据，返回的唯一值是未排序的。value_counts用于计算一个Series中各值出现的概率。isin方法计算表示Series各值是否包含传入的值序列中的布尔型数组。 In [43]: s1 = Series([&#39;c&#39;, &#39;c&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;]) In [45]: s1.unique() Out[45]: array([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;], dtype=object) In [46]: pd.value_counts(s1) Out[46]: b 2 c 2 d 1 f 1 e 1 a 1 dtype: int64 In [52]: pd.value_counts(s1, sort=False) Out[52]: a 1 c 2 e 1 b 2 f 1 d 1 dtype: int64 In [54]: mask = s1.isin([&#39;c&#39;, &#39;b&#39;]) In [55]: mask Out[55]: 0 True 1 True 2 True 3 True 4 False 5 False 6 False 7 False dtype: bool 处理缺失数据NA处理方法 方法 说明 dropna 根据各标签的值中是否存在缺失数据对轴标签进行过滤，可通过阈值调节对缺失值的容忍度 fillna 用指定值或插值方法（如ffill或bfill）填充缺失数据 isnull 返回一个含有布尔值的对象，这些布尔值表示哪些值是缺失值/NA，改对象的类型与源类型一样 notnull isnull的否定式 滤除缺失数据对于Series很简单，只需要dropna可以轻松的滤除缺失数据，但在DataFrame中可以选择丢弃全NA或者含有NA的行或列。dropna默认丢弃任何含有缺失值的行。 In [60]: data Out[60]: 0 1 2 0 1.0 6.5 3.0 1 1.0 NaN NaN 2 NaN NaN NaN 3 NaN 6.5 3.0 In [61]: data.dropna() Out[61]: 0 1 2 0 1.0 6.5 3.0 In [62]: data Out[62]: 0 1 2 0 1.0 6.5 3.0 1 1.0 NaN NaN 2 NaN NaN NaN 3 NaN 6.5 3.0 # 当限定的行或列全为NA时才滤除 In [63]: data.dropna(how=&#39;all&#39;) Out[63]: 0 1 2 0 1.0 6.5 3.0 1 1.0 NaN NaN 3 NaN 6.5 3.0 In [64]: data.dropna(axis=1, how=&#39;all&#39;) Out[64]: 0 1 2 0 1.0 6.5 3.0 1 1.0 NaN NaN 2 NaN NaN NaN 3 NaN 6.5 3.0 填充缺失数据对于NA值，可以使用fillna方法，fillna方法默认返回新对象，但可以通过inplace=True参数原地修改。 In [66]: data Out[66]: 0 1 2 0 1.0 6.5 3.0 1 1.0 NaN NaN 2 NaN NaN NaN 3 NaN 6.5 3.0 In [67]: data2 = data In [68]: data2.fillna(0, inplace=True) In [69]: data2 Out[69]: 0 1 2 0 1.0 6.5 3.0 1 1.0 0.0 0.0 2 0.0 0.0 0.0 3 0.0 6.5 3.0 fillna函数的参数 参数 | 说明value | 用于填充缺失值的标量值或字典对象method | 插值方式，如果函数调用时未指定其他参数的话，默认为”ffill”axis | 待填充的轴，默认0inplace | 修改调用者对象而不产生副本limit | 可以连续填充的最大数量 层次化索引层次化索引，是pandas可以在一个轴上拥有多个索引级别，它可以以低维度形式处理高维数据。 In [71]: data = Series(np.random.randn(10), index=[[&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39; ...: ,&#39;c&#39;,&#39;d&#39;,&#39;d&#39;],[1,2,3,1,2,3,1,2,2,3]]) In [72]: data Out[72]: a 1 0.877453 2 1.031048 3 -0.585296 b 1 0.070123 2 -0.988380 3 -1.118804 c 1 0.963368 2 -0.304830 d 2 -0.030440 3 0.338128 dtype: float64 In [73]: data.a Out[73]: 1 0.877453 2 1.031048 3 -0.585296 dtype: float64 重排分级顺序In [12]: frame Out[12]: state Ohio Colorado color Green Red Green key1 key2 a 1 0 1 2 2 3 4 5 b 1 6 7 8 2 9 10 11 In [13]: frame.swaplevel(&#39;key1&#39;, &#39;key2&#39;) Out[13]: state Ohio Colorado color Green Red Green key2 key1 1 a 0 1 2 2 a 3 4 5 1 b 6 7 8 2 b 9 10 11 根据级别汇总统计In [13]: frame Out[13]: state Ohio Colorado color Green Red Green key1 key2 a 1 0 1 2 2 3 4 5 b 1 6 7 8 2 9 10 11 In [14]: frame.sum(level=&#39;key2&#39;) Out[14]: state Ohio Colorado color Green Red Green key2 1 6 8 10 2 12 14 16 In [15]: frame.sum(level=&#39;color&#39;, axis=1) Out[15]: color Green Red key1 key2 a 1 2 1 2 8 4 b 1 14 7 2 20 10 使用DataFrame的列DataFrame的set_index函数会将其一个或多个列转换成行索引，并创建一个新的DataFrame In [17]: frame Out[17]: a b c d 0 0 7 one 0 1 1 6 one 1 2 2 5 one 2 3 3 4 two 0 4 4 3 two 1 5 5 2 two 2 6 6 1 two 3 In [18]: frame2 = frame.set_index([&#39;c&#39;,&#39;d&#39;]) In [19]: frame2 Out[19]: a b c d one 0 0 7 1 1 6 2 2 5 two 0 3 4 1 4 3 2 5 2 3 6 1]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas笔记-基础篇]]></title>
    <url>%2Fposts%2F8493c310%2F</url>
    <content type="text"><![CDATA[SeriesSeries是一种类似一维数组的对象，由一组数据和一组与之相关的数据索引组成 In [9]: obj = Series([4,7,-5,3]) In [10]: obj.index Out[10]: RangeIndex(start=0, stop=4, step=1) In [11]: obj.values Out[11]: array([ 4, 7, -5, 3], dtype=int64) In [12]: obj2 = Series([4,7,-5,3], index=[&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;]) In [13]: obj2.index Out[13]: Index([&#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;], dtype=&#39;object&#39;) In [14]: obj2[&#39;a&#39;] Out[14]: 3 In [15]: obj2[[&#39;c&#39;,&#39;b&#39;,&#39;a&#39;]] Out[15]: c -5 b 7 a 3 dtype: int64 Numpy 数组运算都会保留索引和值之间的链接，但这些操作并不会改变原Series本身（与ndarray的选区操作相对） In [19]: obj2[obj2&gt;0] Out[19]: d 4 b 7 a 3 dtype: int64 In [20]: obj2 * 2 Out[20]: d 8 b 14 c -10 a 6 dtype: int64 In [23]: np.exp(obj2) Out[23]: d 54.598150 b 1096.633158 c 0.006738 a 20.085537 dtype: float64 还可以将Series看成一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要的字典参数函数中。 In [26]: obj2 Out[26]: d 4 b 7 c -5 a 3 dtype: int64 In [27]: &#39;d&#39; in obj2 Out[27]: True In [28]: 4 in obj2 Out[28]: False In [29]: 4 in obj2.values Out[29]: True 所有数据被放在一个Python字典中时，也可以直接用这个字典来创建Series。如果只传入一个字典，结果Series的索引就是原字典的键（有序排列）。 In [30]: sdata = {&#39;Ohio&#39;: 3500, &#39;Texas&#39;: 71000, &#39;Oregon&#39;: 16000, &#39;Utah&#39;:5000} In [31]: obj3 = Series(sdata) In [32]: obj3 Out[32]: Ohio 3500 Texas 71000 Oregon 16000 Utah 5000 dtype: int64 In [33]: status = [&#39;California&#39;, &#39;Ohio&#39;, &#39;Oregon&#39;, &#39;Texas&#39;] # 跟索引相匹配的3个值会被找出来并放到相应的位置是，如果找不到值就为NaN In [34]: obj4 = Series(sdata, index=status) In [35]: obj4 Out[35]: California NaN Ohio 3500.0 Oregon 16000.0 Texas 71000.0 dtype: float64 Series可用pd.isnull或obj4.isnull()两种方式判断是否为空 In [36]: pd.isnull(obj4) Out[36]: California True Ohio False Oregon False Texas False dtype: bool In [37]: pd.notnull(obj4) Out[37]: California False Ohio True Oregon True Texas True dtype: bool In [38]: obj4.isnull() Out[38]: California True Ohio False Oregon False Texas False dtype: bool Series还有个重要的特征就是进行数学运算的时候会自动对齐不同索引的数据。 In [41]: obj4+obj3 Out[41]: California NaN Ohio 7000.0 Oregon 32000.0 Texas 142000.0 Utah NaN dtype: float64 Series对象本身和索引都有一个Name属性，Series的索引可以通过赋值的方式修改。 In [42]: obj4 Out[42]: California NaN Ohio 3500.0 Oregon 16000.0 Texas 71000.0 dtype: float64 In [43]: obj4.name = &#39;population&#39; In [44]: obj4.index.name = &#39;state&#39; In [45]: obj4 Out[45]: state California NaN Ohio 3500.0 Oregon 16000.0 Texas 71000.0 Name: population, dtype: float64 In [46]: obj.index Out[46]: RangeIndex(start=0, stop=4, step=1) In [47]: obj.index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] In [48]: obj Out[48]: a 4 b 7 c -5 d 3 dtype: int64 DataFrameDataFrame可以被看做有Series组成的字典（共用一个索引），构建DataFrame最常用的方法是直接传入一个由等长列表或Numpy数组组成的字典。 In [49]: data = {&#39;state&#39;: [&#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Nevada&#39;, &#39;Nevada&#39;], ...: &#39;year&#39;: [2000, 2001, 2002, 2001, 2002], ...: &#39;pop&#39;: [1.5, 1.7, 3.6, 2.4, 2.9]} In [50]: frame = DataFrame(data) In [51]: frame Out[51]: state year pop 0 Ohio 2000 1.5 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 当传入的列在数据中找不到时，就会产生NA值。DataFrame还可以通过类似字典标记的方式或属性的方式获取DataFrame为一个Series。但使用属性的方式有可能与预留方法名重名，推荐使用字典标记方式 In [53]: frame2 = DataFrame(data, columns=[&#39;year&#39;, &#39;state&#39;, &#39;pop&#39;, &#39;debt&#39;], ind ...: ex=[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39; ...: ]) In [54]: frame2 Out[54]: year state pop debt one 2000 Ohio 1.5 NaN two 2001 Ohio 1.7 NaN three 2002 Ohio 3.6 NaN four 2001 Nevada 2.4 NaN five 2002 Nevada 2.9 NaN In [57]: frame2.state Out[57]: one Ohio two Ohio three Ohio four Nevada five Nevada Name: state, dtype: object In [58]: frame2[&#39;state&#39;] Out[58]: one Ohio two Ohio three Ohio four Nevada five Nevada Name: state, dtype: object DataFrame支持给某一列附上一个标量的值或者一组值。将列表或者数组赋值给某个列时，其长度必须与DataFrame长度匹配。如果赋值的是Series，就会精准匹配DataFrame的索引，所有空位都将被填上缺失值。 In [75]: frame2[&#39;debt&#39;] = 1 In [76]: frame2 Out[76]: year state pop debt one 2000 Ohio 1.5 1 two 2001 Ohio 1.7 1 three 2002 Ohio 3.6 1 four 2001 Nevada 2.4 1 five 2002 Nevada 2.9 1 In [77]: frame2[&#39;debt&#39;] = np.arange(5.) In [78]: frame2 Out[78]: year state pop debt one 2000 Ohio 1.5 0.0 two 2001 Ohio 1.7 1.0 three 2002 Ohio 3.6 2.0 four 2001 Nevada 2.4 3.0 five 2002 Nevada 2.9 4.0 索引对象DataFrame的index是不可以直接修改的，即frame.index[1] = 5是不可取的。以下提供了index的方法和属性 方法 说明 append 链接另一个index对象，产生一个新的index diff 计算差集，并得到一个index intersection 计算交集 union 计算并集 isin 计算一个指示各值是否都包含在参数集合中的布尔型数组 delete 删除索引i处的元素，并的到新的index drop 删除传入的值，并得到新的index insert 将元素插入到索引i处，并得到新的index is_monotonic 当个元素均大于等于前一个元素时，返回True is_union 当index没有重复值时，返回True unique 计算index中唯一值得数组 基本功能重新索引reindex可以创建一个适应新索引的新对象。 In [86]: obj = Series([4.5, 7.2, -5.3, 3.6], index=[&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;]) In [87]: obj Out[87]: d 4.5 b 7.2 a -5.3 c 3.6 dtype: float64 In [88]: obj.reindex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], fill_value=0) Out[88]: a -5.3 b 7.2 c 3.6 d 4.5 e 0.0 dtype: float64 reindex重新索引时还可以做一些插值处理，method选项即可达到此目的，例如ffill就可以实现向前填充值。 In [90]: obj3 Out[90]: 0 blue 2 purple 4 yellow dtype: object In [91]: obj3.reindex(range(6), method=&#39;ffill&#39;) Out[91]: 0 blue 1 blue 2 purple 3 purple 4 yellow 5 yellow dtype: object reindex中可用的method选项如下： 参数 说明 ffill、pad 向前填充（或搬运）值 bfill、backfill 向后填充（或搬运）值 reindex函数的参数参数 | 说明index | 用作索引的新序列method | 插值（填充）方式fill_value | 在重新索引过程中，需要引入缺失值时使用的替代值limit | 向前或向后填充时的最大值level | 在MultiIndex的指定级别上匹配简单索引，否则选取其子集copy | 默认True，无论何时都复制；如果为False，则新旧相等就不复制 丢弃制定轴上的项使用drop方法可以丢弃某条轴上一个或多个项 In [94]: frame.drop(0) Out[94]: state year pop 1 Ohio 2001 1.7 2 Ohio 2002 3.6 3 Nevada 2001 2.4 4 Nevada 2002 2.9 In [95]: frame.drop(&#39;state&#39;, axis=1) Out[95]: year pop 0 2000 1.5 1 2001 1.7 2 2002 3.6 3 2001 2.4 4 2002 2.9 索引、选取和过滤 类型 说明 obj[val] 选取DataFrame的单个列或一组列，在一些特殊情况下回比较便利：布尔型数组（过滤行）、切片（行切片）、布尔型DataFrame（根据条件设置值） obj.ix[val] 选取DataFrame的单个行或一组行 obj.ix[:, val] 选取单个列或列子集 obj.ix[val1, val2] 同时选取行和列 reindex方法 将一个或多个轴匹配到新索引 xs方法 根据标签选取单行或单列，并返回一个Series icol、irow 根据整数位置选取单列或单行，并返回一个Series get_value、set_value方法 根据行标签和列标签选取单个值 算术运算和数据对齐pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引，则结果的索引就是该索引对的并集。自动的数据对齐操作在不重叠的索引处引入了NA值。 在算术方法中填充值不使用+可以使用add方法进行相加，其中可以添加fill_value参数填充索引不重叠产生的缺省值。 In [14]: df1 Out[14]: a b c d 0 0.0 1.0 2.0 3.0 1 4.0 5.0 6.0 7.0 2 8.0 9.0 10.0 11.0 In [15]: df2 Out[15]: a b c d e 0 0.0 1.0 2.0 3.0 4.0 1 5.0 6.0 7.0 8.0 9.0 2 10.0 11.0 12.0 13.0 14.0 3 15.0 16.0 17.0 18.0 19.0 In [16]: df1.add(df2, fill_value=0) Out[16]: a b c d e 0 0.0 2.0 4.0 6.0 4.0 1 9.0 11.0 13.0 15.0 9.0 2 18.0 20.0 22.0 24.0 14.0 3 15.0 16.0 17.0 18.0 19.0 灵活的算术方法 方法 说明 add 加法 sub 减法 div 除法 mul 乘法 DataFrame和Series之间的运算默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列然后沿着行一直向下广播： In [17]: df1 Out[17]: a b c d 0 0.0 1.0 2.0 3.0 1 4.0 5.0 6.0 7.0 2 8.0 9.0 10.0 11.0 In [19]: s1 = df1.iloc[1] In [20]: s1 Out[20]: a 4.0 b 5.0 c 6.0 d 7.0 Name: 1, dtype: float64 In [21]: df1 - s1 Out[21]: a b c d 0 -4.0 -4.0 -4.0 -4.0 1 0.0 0.0 0.0 0.0 2 4.0 4.0 4.0 4.0 如果希望匹配行并在列上广播，则必须使用算术运算方法 In [24]: df1 Out[24]: a b c d 0 0.0 1.0 2.0 3.0 1 4.0 5.0 6.0 7.0 2 8.0 9.0 10.0 11.0 In [25]: s1 = Series([1,2,3], index=[0,1,2]) In [26]: s1 Out[26]: 0 1 1 2 2 3 dtype: int64 In [27]: df1.add(s1, axis=0) Out[27]: a b c d 0 1.0 2.0 3.0 4.0 1 6.0 7.0 8.0 9.0 2 11.0 12.0 13.0 14.0 函数应用和映射 Numpy的ufuncs也可用于操作pandas对象 也可用DataFrame的apply方法实现 In [29]: frame Out[29]: b c d Utah -0.677682 0.247555 0.145010 Ohio -0.120664 0.618269 1.170003 Texas 0.692635 -1.465877 0.432430 Oregon -0.103928 1.032560 1.944111 # Numpy的ufuncs In [30]: np.abs(frame) Out[30]: b c d Utah 0.677682 0.247555 0.145010 Ohio 0.120664 0.618269 1.170003 Texas 0.692635 1.465877 0.432430 Oregon 0.103928 1.032560 1.944111 In [31]: f = lambda x: x.max() - x.min() # apply方法 In [32]: frame.apply(f) Out[32]: b 1.370317 c 2.498437 d 1.799101 dtype: float64 In [33]: frame.apply(f, axis=1) Out[33]: Utah 0.925237 Ohio 1.290666 Texas 2.158512 Oregon 2.048038 dtype: float64 处理元素级的Python函数，可以使用applymap(对于DataFrame)，对于Series可以使用map方法 In [34]: f2 = lambda x: &#39;%.2f&#39; % x # 对DataFrame In [35]: frame.applymap(f2) Out[35]: b c d Utah -0.68 0.25 0.15 Ohio -0.12 0.62 1.17 Texas 0.69 -1.47 0.43 Oregon -0.10 1.03 1.94 # 对Series In [36]: frame[&#39;b&#39;].map(f2) Out[36]: Utah -0.68 Ohio -0.12 Texas 0.69 Oregon -0.10 Name: b, dtype: object 排名和排序可用sort_index方法进行排序，其中可以设定轴与降序升序 In [42]: frame Out[42]: d a b c three 0 1 2 3 one 4 5 6 7 In [43]: frame.sort_index() Out[43]: d a b c one 4 5 6 7 three 0 1 2 3 In [44]: frame.sort_index(axis=1) Out[44]: a b c d three 1 2 3 0 one 5 6 7 4 # 降序排序，默认ascending=True，为升序 In [45]: frame.sort_index(axis=1, ascending=False) Out[45]: d c b a three 0 3 2 1 one 4 7 6 5 rank函数可以为各组分配一个平均排名，默认是排名越高数值越大(ascending=True) In [65]: obj Out[65]: 0 7 1 -5 2 7 3 4 4 3 5 0 6 4 dtype: int64 In [66]: obj.rank() Out[66]: 0 6.5 1 1.0 2 6.5 3 4.5 4 3.0 5 2.0 6 4.5 dtype: float64 # 降序排名，因为7，4出现了两次，所以排名带有.5 In [67]: obj.rank(ascending=False) Out[67]: 0 1.5 1 7.0 2 1.5 3 3.5 4 5.0 5 6.0 6 3.5 dtype: float64 In [68]: obj.rank(method=&#39;first&#39;, ascending=False) Out[68]: 0 1.0 1 7.0 2 2.0 3 3.0 4 5.0 5 6.0 6 4.0 dtype: float64 排名时用于破坏平级关系的method选项 method 说明 average 默认：在相等分组中，为各个值分配平均排名 min 使用整个分组的最小排名 max 使用整个分组的最大排名 first 按值在原始数据中的出现顺序分配排名 带有重复值得轴索引虽然许多pandas函数如reindex都要求标签唯一，但这并不是强制性的。 In [69]: obj = Series(range(5), index=[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;]) In [70]: obj Out[70]: a 0 a 1 b 2 c 3 c 4 dtype: int64 In [71]: obj[&#39;a&#39;] Out[71]: a 0 a 1 dtype: int64 In [72]: obj.is_unique Out[72]: True In [73]: obj.index.is_unique Out[73]: False In [74]: obj[0] = 1 In [75]: obj Out[75]: a 1 a 1 b 2 c 3 c 4 dtype: int64 In [76]: obj.is_unique Out[76]: False]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy笔记-进阶篇]]></title>
    <url>%2Fposts%2F87847f8%2F</url>
    <content type="text"><![CDATA[利用数组进行数据分析np.where是三元表达式x if condition else y的矢量化版 In [169]: arr Out[169]: array([[-2.09280349e-01, -2.08776777e+00, 1.18959772e+00, -1.30555812e-01], [-1.05658371e+00, 2.66633933e+00, 4.47784003e-01, 5.22445402e-01], [ 9.67780972e-01, -1.00148828e+00, -1.83185363e-03, 4.53542100e-01], [ 1.33135003e+00, 1.33233678e-01, -4.89156202e-01, 1.16725743e+00]]) # 大于零替换成2，小于零替换成-2 In [170]: np.where(arr&gt;0, 2, -2) Out[170]: array([[-2, -2, 2, -2], [-2, 2, 2, 2], [ 2, -2, -2, 2], [ 2, 2, -2, 2]]) # 大于零替换成2，小于零则不变 In [171]: np.where(arr&gt;0, 2, arr) Out[171]: array([[-2.09280349e-01, -2.08776777e+00, 2.00000000e+00, -1.30555812e-01], [-1.05658371e+00, 2.00000000e+00, 2.00000000e+00, 2.00000000e+00], [ 2.00000000e+00, -1.00148828e+00, -1.83185363e-03, 2.00000000e+00], [ 2.00000000e+00, 2.00000000e+00, -4.89156202e-01, 2.00000000e+00]]) 数学和统计方法以下方法可以在对某个轴向的数据进行统计，（axis=1,纵向；axis=0，横向） In [24]: arr Out[24]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]) In [25]: arr.sum() Out[25]: 190 In [26]: arr.sum(axis=1) Out[26]: array([ 6, 22, 38, 54, 70]) In [27]: arr.sum(axis=0) Out[27]: array([40, 45, 50, 55]) 方法 说明 sum 对数组中所有或者某个轴向的数据进行求和，零长度的数组sum为0 mean 算数平均值，零长度的数组mean为NaN std、var 标准差、方差 min、max 最小值、最大值 argmin、argmax 最小、最大值索引 cumsum 所有元素的累计和 cumprod 所有元素累计积 用于布尔型数组的方法用于上面的方法中，布尔值会被强制转换成1和0。因此可以使用sum对布尔型数组的True值进行计数。 In [38]: arr &gt; 5 Out[38]: array([[False, False, False, False], [False, False, True, True], [ True, True, True, True], [ True, True, True, True], [ True, True, True, True]]) In [40]: (arr&gt;5).sum() Out[40]: 14 更有any和all方法可以判断布尔型数组中是否存在/全是True In [41]: bools = np.array([False, False, True, True, False]) In [42]: bools.any() Out[42]: True In [43]: bools.all() Out[43]: False 排序Numpy数组也可以使用sort方法就地排序，而np.sort()方法生成的是数组的副本，两者都可以在多维数组任意一个轴向上排序。 In [79]: arr Out[79]: array([[20, 19, 18, 17], [16, 15, 14, 13], [12, 11, 10, 9], [ 8, 7, 6, 5], [ 4, 3, 2, 1]]) In [80]: arr.sort(axis=1) In [81]: arr Out[81]: array([[17, 18, 19, 20], [13, 14, 15, 16], [ 9, 10, 11, 12], [ 5, 6, 7, 8], [ 1, 2, 3, 4]]) In [82]: arr.sort(axis=0) In [83]: arr Out[83]: array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16], [17, 18, 19, 20]]) 唯一化以及其他的集合逻辑np.unique()方法可计算数组中的唯一值；np.in1d()可测试数组值得成员资格，返回布尔数组。 # 唯一值 In [89]: names = np.array([&#39;Bob&#39;, &#39;Bob&#39;, &#39;Bob&#39;, &#39;Will&#39;, &#39;Will&#39;, &#39;Joe&#39;]) In [90]: np.unique(names) Out[90]: array([&#39;Bob&#39;, &#39;Joe&#39;, &#39;Will&#39;], dtype=&#39;&lt;U4&#39;) # 成员资格 In [91]: values = np.array([1,2,3,3,3,4,5]) In [92]: np.in1d(values, [1,2,4]) Out[92]: array([ True, True, False, False, False, True, False]) 方法 说明 unique(x) 计算x中的唯一值，并返回有序结果 intersect1d(x, y) 计算x, y中的公共元素，并返回有序结果 union1d(x, y) 计算x, y的并集，返回有序结果 in1d(x, y) 得到一个”x元素是否包含于y”的布尔型数组 setdiff1d(x, y) 集合的差，即元素在x中且不在y中 setxor1d(x, y) 集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素（异或） 线性代数emmm。。反正看不懂，就先记个函数叭 函数 说明 diag 以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换为方阵（非对角线元素为0） dot 矩阵乘法 trace 计算对角线元素的和 det 计算矩阵行列式 eig 计算方阵的本征值和本征向量 inv 计算方阵的逆 pinv 计算矩阵的Moore-Penrose伪逆 qr 计算QR分解 svd 计算奇异值分解 solve 解线性方程组Ax=b，其中A为一个方阵 lstsq 计算Ax=b的最小二乘解 随机数生成numpy.random效率比Python标准库的随机快的多 函数 说明 seed 确定随机生成器的种子 permutation 返回一个序列的随机排列或返回一个随机排列范围 shuffle 对一个序列就地随机排列 rand 产生均匀分布的样本值 randint 从给定的上下限范围内随机选取整数 randn 产生正态分布（平均值0，标准差1）的样本值 binomial 产生二项分布的样本值 normal 产生正态（高斯）分布的样本值 beta 产生Beta分布的样本值 chisquare 产生卡方分布的样本值 gamma 产生Gamma分布的样本值 uniform 产生[0, 1)中均匀分布的样本值 范例：随机漫步随机漫步理论(Random Walk Theory)认为，证券价格的波动是随机的，像一个在广场上行走的人一样，价格的下一步将走向哪里，是没有规律的。证券市场中，价格的走向受到多方面因素的影响。一件不起眼的小事也可能对市场产生巨大的影响。从长时间的价格走势图上也可以看出，价格的上下起伏的机会差不多是均等的。 Python标准库实现import random position = 0 walk = [position] steps = 1000 for i in range(steps): step = 1 if random.randint(0, 1) else -1 position += step walk.append(position) # 输出最大值 print(max(walk)) # 输出最小值 print(min(walk)) # 输出第一个到10时的索引 start, end = 0, 10 for k, v in enumerate(walk): if start == end: print(k) break start += v if k == len(walk): print(&quot;最终都没有到10&quot;) 使用Numpy In [98]: nsteps = 1000 # 随机生成nsteps个[0,2)之间的随机值 In [99]: draws = np.random.randint(0, 2, size=nsteps) In [100]: steps = np.where(draws&gt;0, 1, -1) # 元素累计和的数组 In [101]: walk = steps.cumsum() In [104]: walk.min() Out[104]: -10 In [105]: walk.max() Out[105]: 28 # 得到数组中第一个最大值的索引(第一个True) In [106]: (walk &gt;= 10).argmax() Out[106]: 171 总结很明显的可以看出，使用Numpy代码更加优雅易读，且通过IPython的%timeit测试两个版本的速度，使用标准库的平均时间为4.57 ms，而使用Numpy的平均时间为2.68 ms。]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy 笔记-基础篇]]></title>
    <url>%2Fposts%2Fca37cdbd%2F</url>
    <content type="text"><![CDATA[创建 ndarray常用方法array函数可接受一切序列类型对象 In [2]: data1 = [6.1, 5, 4, 3, 1] In [3]: arr1 = np.array(data1) In [4]: arr1 Out[4]: array([6.1, 5, 4, 3, 1]) In [5]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]] In [6]: arr2 = np.array(data2) In [7]: arr2 Out[7]: array([[1, 2, 3, 4], [5, 6, 7, 8]]) In [8]: arr2.shape Out[8]: (2, 4) In [9]: arr2.dtype Out[9]: dtype(&#39;int32&#39;) 除非显式说明，np.array会尝试为新建的这个数组判断一个较为合适的数据类型。数据类型保存在特殊的dtype对象中。比如上面的两个例子中。我们有： In [19]: arr1.dtype Out[19]: dtype(&#39;float64&#39;) In [20]: arr2.dtype Out[20]: dtype(&#39;int32&#39;) 其他新建数组方法 函数 说明 asarray 将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制 arange np.arange(5) → array([0, 1, 2, 3, 4]) ones np.ones((2,2)) → array([[1., 1.], [1., 1.]]) ones_like np.ones_like([1,2,3]) → array([1, 1, 1]) zeros np.zeros((2,2)) → array([[0., 0.], [0., 0.]]) zeros_like np.ones_like([1,2,3]) → array([0, 0, 0]) empty、empty_like np.empty(1) → array([5.06106712e+58]) eys、identity np.eye(2) → array([[1., 0.], [0., 1.]]) X 根据指定的形状和dtype创建一个为X的数组， X_like以另一个数组为参数，并根据其形状和dtype创建一个为X的数组 ndarray 的数据类型 调用astype会创建一个新的数组，而不是对原数组进行修改 # 显式说明类型 In [39]: arr1 = np.array([1, 2, 3], dtype=np.float64) In [40]: arr1 Out[40]: array([1., 2., 3.]) In [41]: arr1.dtype Out[41]: dtype(&#39;float64&#39;) # 修改类型 In [42]: int_arr1 = arr1.astype(np.int64) In [43]: int_arr1 Out[43]: array([1, 2, 3], dtype=int64) In [44]: int_arr1.dtype Out[44]: dtype(&#39;int64&#39;) # 另一种修改类型方法 In [45]: int_arr = np.arange(10) In [47]: float_arr = np.array([.1, .3, .5,.6], dtype=np.float64) In [48]: int_arr.astype(float_arr.dtype) Out[48]: array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]) 数组和标量之间的运算FBI WARNING！离！散！数！学！警！告！ In [49]: arr = np.array([[1., 2., 3.], [4., 5., 6.]]) In [50]: arr Out[50]: array([[1., 2., 3.], [4., 5., 6.]]) In [51]: arr * arr Out[51]: array([[ 1., 4., 9.], [16., 25., 36.]]) In [52]: arr - arr Out[52]: array([[0., 0., 0.], [0., 0., 0.]]) In [53]: arr + arr Out[53]: array([[ 2., 4., 6.], [ 8., 10., 12.]]) In [54]: arr / arr Out[54]: array([[1., 1., 1.], [1., 1., 1.]]) In [55]: 1 / arr Out[55]: array([[1. , 0.5 , 0.33333333], [0.25 , 0.2 , 0.16666667]]) In [57]: arr ** 0.5 Out[57]: array([[1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974]]) 基本的索引和切片切片的注意事项NumPy中将一个标量赋值给切片，会自动修改整个选取！并且将切片赋值给一个变量，修改变量原数组也会改变！如想得到一个副本，需要copy或者deepcopy # 切片与修改切片 In [58]: arr = np.arange(10) In [59]: arr[5] Out[59]: 5 In [60]: arr[5:8] Out[60]: array([5, 6, 7]) In [61]: arr[5:8] = 12 In [62]: arr Out[62]: array([ 0, 1, 2, 3, 4, 12, 12, 12, 8, 9]) # 赋值变量后修改切片 In [63]: arr_sli = arr[5:8] In [64]: arr_sli[1] = 1234 In [65]: arr Out[65]: array([ 0, 1, 2, 3, 4, 12, 1234, 12, 8, 9]) In [66]: arr_sli[:] = 64 In [67]: arr Out[67]: array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9]) 由于 Numpy 是的设计目的是处理大数据，所以坚持将数据复制出来会产生极大的性能和内存问题。 高维数组索引类似Python基本库中的多维列表索引，但Numpy中多维数组可以使用以逗号隔开的索引列表来选取单个元素 In [89]: arr2d Out[89]: array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) In [90]: arr2d[1][1] Out[90]: 5 # 等价 In [91]: arr2d[1,1] Out[91]: 5 切片索引# 第一项切行，第二项切列 In [92]: arr2d Out[92]: array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) In [93]: arr2d[:2, 1:] Out[93]: array([[2, 3], [5, 6]]) 布尔索引布尔型数组的长度必须跟被索引的轴长度一致，并且可以和切片、整数混合使用 In [95]: names Out[95]: array([&#39;Bob&#39;, &#39;Joe&#39;, &#39;Will&#39;, &#39;Bob&#39;, &#39;Will&#39;, &#39;Joe&#39;, &#39;Joe&#39;], dtype=&#39;&lt;U4&#39;) In [96]: names == &#39;Bob&#39; Out[96]: array([ True, False, False, True, False, False, False]) In [98]: from numpy.random import randn In [99]: data = randn(7, 4) In [100]: data Out[100]: array([[ 1.0414046 , 0.27541176, -0.28867275, 0.43976932], [ 1.41040224, 0.85299112, -1.25119339, -0.22021196], [ 0.6567735 , -1.68611377, 1.21111831, 0.30837087], [-1.71472061, 1.83107771, -0.4621784 , -0.44085432], [ 1.62355481, 1.05545767, 1.03071674, -0.58314536], [ 1.42174078, 0.37195811, 0.33015409, -1.5331736 ], [ 0.30902783, -0.65909982, -0.74522413, -0.40299012]]) In [101]: data[names == &#39;Bob&#39;] Out[101]: array([[ 1.0414046 , 0.27541176, -0.28867275, 0.43976932], [-1.71472061, 1.83107771, -0.4621784 , -0.44085432]]) # 混合使用 In [102]: data[names==&#39;Bob&#39;, 2:] Out[102]: array([[-0.28867275, 0.43976932], [-0.4621784 , -0.44085432]]) # 否定用法 In [103]: names != &#39;Bob&#39; Out[103]: array([False, True, True, False, True, True, True]) In [105]: data[~(names==&#39;Bob&#39;)] Out[105]: array([[ 1.41040224, 0.85299112, -1.25119339, -0.22021196], [ 0.6567735 , -1.68611377, 1.21111831, 0.30837087], [ 1.62355481, 1.05545767, 1.03071674, -0.58314536], [ 1.42174078, 0.37195811, 0.33015409, -1.5331736 ], [ 0.30902783, -0.65909982, -0.74522413, -0.40299012]]) # 布尔条件 &amp; | （不可使用 and or） In [107]: mask = (names == &#39;Bob&#39;) | (names == &#39;Will&#39;) In [108]: mask Out[108]: array([ True, False, True, True, True, False, False]) # 布尔索引使用示例 In [110]: data[data&lt;0]=0 In [111]: data Out[111]: array([[1.0414046 , 0.27541176, 0. , 0.43976932], [1.41040224, 0.85299112, 0. , 0. ], [0.6567735 , 0. , 1.21111831, 0.30837087], [0. , 1.83107771, 0. , 0. ], [1.62355481, 1.05545767, 1.03071674, 0. ], [1.42174078, 0.37195811, 0.33015409, 0. ], [0.30902783, 0. , 0. , 0. ]]) 花式索引花式索引和切片不同，他总是将数据复制进新数组 In [114]: arr Out[114]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]]) # 取1,5,7,2行区域（形成新数组） In [115]: arr[[1,5,7,2]] Out[115]: array([[ 4, 5, 6, 7], [20, 21, 22, 23], [28, 29, 30, 31], [ 8, 9, 10, 11]]) # 取(1, 0), (5, 3), (7, 1), (2, 2)位置的元素区域 In [116]: arr[[1,5,7,2], [0,3,1,2]] Out[116]: array([ 4, 23, 29, 10]) # 取1,5,7,2行区域，列按[0,3,1,2]顺序排列 In [117]: arr[[1,5,7,2]][:, [0,3,1,2]] Out[117]: array([[ 4, 7, 5, 6], [20, 23, 21, 22], [28, 31, 29, 30], [ 8, 11, 9, 10]]) # 花式索引是生成新数组 In [122]: arr2 = arr[[1,5,7,2]] In [123]: arr2 Out[123]: array([[ 4, 5, 6, 7], [20, 21, 22, 23], [28, 29, 30, 31], [ 8, 9, 10, 11]]) In [124]: arr2 = 1 In [125]: arr Out[125]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]]) 数组转置和轴对换In [127]: arr Out[127]: array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) In [128]: arr.T Out[128]: array([[ 0, 5, 10], [ 1, 6, 11], [ 2, 7, 12], [ 3, 8, 13], [ 4, 9, 14]]) # 看不懂。。 In [130]: arr Out[130]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]]) In [132]: arr.transpose((1,0,2)) Out[132]: array([[[ 0, 1, 2, 3], [ 8, 9, 10, 11]], [[ 4, 5, 6, 7], [12, 13, 14, 15]]]) 通用函数：快速的元素级数组函数通用函数是一种能对ndarray中的数据执行元素级运算的函数。 In [133]: arr = np.arange(10) # 平方根 In [134]: np.sqrt(arr) Out[134]: array([0. , 1. , 1.41421356, 1.73205081, 2. , 2.23606798, 2.44948974, 2.64575131, 2.82842712, 3. ]) # e为底的指数 In [135]: np.exp(arr) Out[135]: array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03]) # 元素级最大值 In [136]: x = randn(8) In [137]: y = randn(8) In [139]: x Out[139]: array([ 0.29123626, 2.54672169, -1.0185621 , 0.46756089, -1.72738298, 0.73119483, -0.55088788, -0.14345012]) In [140]: y Out[140]: array([ 1.53812286, 0.28810153, -0.65714547, -1.07375593, 1.31292609, 0.5431188 , -0.18918957, 0.30398994]) In [138]: np.maximum(x, y) Out[138]: array([ 1.53812286, 2.54672169, -0.65714547, 0.46756089, 1.31292609, 0.73119483, -0.18918957, 0.30398994]) 一元ufunc 函数 说明 abs、fabs 计算整数、浮点数或复数的绝对值。对于非复数值，可以使用fabs更快 sqrt 平方根 square 平方 exp 以e为底的指数 log、log10、log2、log1p 自然对数、10为底、2为底、log(1+x) sign 计算各元素正负号1(正数)0(零)-1(负数) ceil 向上取整 floor 向下取整 rint 四舍五入，保留dtype modf 将小数和整数部分以两个独立数组的形式返回 isnan 返回是NaN值的布尔数组 isfinite、isinf 返回是有穷数（非inf、非NaN）、无穷数的布尔数组 cos、cosh、sin、sinh、tan、tanh 普通、双曲型三角函数 arccos、arccosh、arcsin、arcsinh、arctan、arctanh、 反三角函数 logical_not 各元素not x的真值。相当于-arr 二元ufunc 函数 说明 add 对应元素相加 subtract 从第一个数组中减去第二个数组中的元素 multiply 数组相乘 divide、floor_divide 除法、向下圆整除法(丢弃余数) power A数组的B次方 maximum、fmax 最大值、fmax忽略NaN minimum、fmin 最小值、fmin忽略NaN mod 取模 copysign 将B数组值的符号复制给第一个数组 greater、greater_equal、less、less_equal、equal、not_equal 比较运算，生成布尔数组，&gt;、&gt;=、&lt;、&lt;=、==、!= logical_and、logical_or、logical_xor 元素级真值逻辑运算，相当于&amp;、&#124; 、^]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构题目总结(C 语言描述)]]></title>
    <url>%2Fposts%2Faa2472f4%2F</url>
    <content type="text"><![CDATA[~正文隐藏~ 2007 年*完成排序的归并算法template&lt;class T&gt; void merge(T* a, int n1, int n2){ //将数组 a 中下标分别从 0...n1-1 和 n1...n1+n2-1 的两个有序序列归并为一个有序序列 T* temp = new T(n1 + n2); int i = 0, j1 = 0, j2 = 0; while (j1&lt;n1 &amp; j2&lt;n2) temp[i++] = (a[j1] &lt;= a[n1+j2] ? a[j1++] : a[n1+j2++]); while (j1&lt;n1) temp[j++] = a[j1++]; while (j2&lt;n2) temp[j++] = a[n1+j2++]; for (int i=0; i&lt;n1+n2; i++) a[i] = temp[i]; delete[]temp; } template&lt;class T&gt; void sort(T* a, int n){ if (n&gt;1){ int n1 = n / 2; int n2 = n - n1; sort(a, n1); // 递归使 a 中前 n1 个元素有序 sort(a+n1, n2); // 递归使 a 中后 n2 个元素有序 merge(a, n1, n2); } } 归并排序图解请点击此处 *试完成求最短路径的 Dijkstra 算法void ShortestPath_DU(MGaph G, int v0, PathMatrix &amp; P, ShortPathTable &amp; D){ // 用 dijkstra 算法求有向图 G 的 v0 顶点到其余顶点 v 的最短路径 P[v] 及其带权长度 D[v] // 若 P[v][w] 为 True 则 w 是从 v0 到 v 当前求得最短路径上的顶点 // final[v] 为 True 当且仅当 v∈S，即已经求得 v0 到 v 的最短路径 int i=0, j, v, w, min; bool final[MAX_VERTEX_NUM]; for (v=0; v&lt;G.vexnum; ++v){ final[v] = FALSE; D[v] = G.arcs[v0][v].adj; for (w=0; w&lt;G.vexnum; ++w) P[v][w] = FALSE; // 设空路径 if (D[v] &lt; INFINITY){ P[v][v0] = TRUE; p[v][v] = TRUE; } } // 初始化， v0 顶点属于 S 集 D[v0] = 0; final[v0] = TRUE; // 开始主循环，每次求得 v0 到某个 v 顶点的最短路径，并加 v 到 S 集合 for (i=1; i&lt;G.vexnum; i++){ //其余 G.vexnum-1 个顶点 min = INFINITY; // 当前所知离 v0 顶点的最短距离 for (w=0; w&lt;G.vexnum; w++) if (!final[w]) // w 顶点在 V-S 中 if (D[w]&lt;min){ // 顶点离 v0 顶点更加 v = w; min = D[w]; } final[v] = TRUE; // 离 v0 顶点最近的 v 添加 S 集 for (w=0; i&lt;G.vexnum; w++) // 更新当前最短路径及距离 if (!final[w] &amp;&amp; (min+G.arcs[v][w].adj &lt; D[w])){ // 修改 D[w] 和 P[w], w∈V-S D[w] = min + G.arcs[v][w].adj; for (j=0; j&lt;G.vexnum; j++) p[w][j] = P[v][j]; // 第 v 行赋值于第 w 行 p[w][w] = TRUE; } } } *若找到指定结点，将该节点与其前驱结点交换，使得经常被查找的结点尽量位于前端，试设计线性表的顺序存储结构和链式存储结构。并写出上面策略的顺从查找算法。int search_seq(SSTable ST, KeyType key){ // 在顺序表中查找关键字等于 key 的数据元素 // 若找到，则将该元素与其前驱交换（若存在），并返回其在表中的位置（交换后），否则为-1 for (int i=0; i&lt;ST.length; i++){ if (key == ST.elem[i]){ // 找到 key 数据元素 if (i&gt;0){ // 存在前驱，交换 ElemType temp = ST.elem[i]; ST.elem[i] = ST.elem[i-1]; ST.elem[i-1] = temp; return i-1; } else{ // 不存在前驱 return 0 } } } return -1 } LinkNode* search_seq2(LinkList L, KeyType key){ // 在链表中 L（带头结点）查找关键字等于 key 的数据元素 // 若找到，则将该元素与其前驱交换（若存在），并返回其在表中的位置（交换后），否则为 NULL LinkNode* p = L-&gt;next, pre = L; while (p != NULL){ if (key == p-&gt;data){ // 找到 key 数据元素 if (pre != L){ // 存在前驱，交换 ElemType temp = pre-&gt;data; pre-&gt;data = p-&gt;data; p-&gt;data = temp; return pre; } else{ // 不存在前驱 return p; } } } return NULL; } 2008 年*编写递归算法，统计并返回以 BT 为树根指针的二叉树叶子结点个数// 采用先序遍历整棵二叉树，统计叶子结点个数 int count = 0; void Count(BTreeNode* BT){ if (BT!=NULL){ if (BT-&gt;lchild == NULL &amp;&amp; BT-&gt;rchild == NULL) count++; Count(BT-&gt;lchild); Count(BT-&gt;rchild); } } *编写以 BST 为树根指针的二叉搜索树上进行查找值为 Item 的结点的非递归算法// 根据 item 的值和当前节点的比较，如果相等就找到返回，如果小于，当前节点移动到右孩子，否则移动找左孩子，重复上述过程。如果最后没有找到，返回 false bool Find(BTreeNode* BST, ElemType &amp;item){ BTreeNode* p = BST; while(!p){ if (item == p-&gt;data){ item = p-&gt;data; return TRUE; } else if (item &lt; p-&gt;data) p = p-&gt;left; else p = p-&gt;right; } return FALSE; } 2009 年*设计在顺序有序表中实现二分查找的算法int BinarySearch(SeqList L, ElemType key){ // 在有序表 L 中查找关键字为 key 的元素，若存在则返回位置，不存在则返回-1 int low = 0, high = L.TableLen-1, mid; while (low &lt;= high){ mid = (low + high) / 2; // 取中间位置 if (L.elem[mid] == key) // 查找成功返回所在位置 return mid; else if (L.elem[mid] &gt; key) // 从前半部分查找 high = mid - 1; else low = mid + 1; } return -1 } 编写一个算法作为将线性表 L 的数据建立一棵二叉排序树int BST_Insert(BiTree &amp;T, KeyType k){ // 在二叉排序树 T 中插入一个关键字 k 的节点 if (T == NULL){ // 原树为空，新插入的记录为根节点 T = (BiTree)malloc(sizeof(BSTNode)); T-&gt;key = k; T-&gt;lchild = T-&gt;rchild = NULL; return 1 // 返回 1，表示树空间申请成功，并建立根节点 } else if (k == T-&gt;key) // 树中存在相同的关键字节点，跳过该节点 else if (k &lt; T-&gt;key) return BST_Insert(T-&gt;lchild, k); // 插入到 T 的左子树 else return BST_Insert(T-&gt;rchild, k); // 插入到 T 的右子树 } void Create_BST(BiTree &amp;T, KeyType L[], int n){ // 用长度为 n 的线性表建立一个二叉排序树 T = NULL; // 初始化 T 为空 for (int i=0; i&lt;n; i++) BST_Insert(T, L[i]); } 带头结点的单链表中，所有节点值递增排序，编写函数。删除表 L 中所有其值大于等于 min 小于等于max 的结点void rangeDelete(LinkList &amp; L, ElemType min, ElemType max){ // q 初始化指向待处理链表的头结点指针，而p始终为下一节点指针 // 如果 q 的下一节点（p）不在min-max范围内，则将 q 的下一节点变为下下一节点(p-&gt;next) ListNode* q = L, *p = L-&gt;next; while (p!=NULL){ if (p-&gt;data &gt;= min &amp;&amp; p-&gt;data &lt;= max){ // 需要删除 q-&gt;next = p-&gt;next; // 将 q 的下一节点取代为下下一节点 free(p); // 清理下一节点的空间 p = q-&gt;next // 重置 p 为删除后链表 L 的下一节点 } else{ q = p; // 同等于 q = q-&gt;next; p = p-&gt;next; } } } *写出求 DFS 生成树（生成森林）的算法，并打印所有的树边int visited[MAXNUM]; // 访问标致数组 void DFSTraverseTree (ALGraph *G){ // 求深度优先生成树（以邻接表表示的图 G) for (int i=0; i&lt;n; i++) visited[i] = FALSE; // 初始化访问标志数组 for (int i=0; i&lt;n; i++) if (!visited[i]) // 第 i 个结点没有访问过 DFSTree(G, i); // 以 vi 为源点开始 DFS 遍历 G } void DFSTree (ALGraph* G, int i){ // 以 vi 为出发点对邻接表表示的图 G 进行深度优先搜索，打印出生成树的边 EdgeNode *p; visited[i] = TRUE; // 标记 vi 已访问 p = G-&gt;adjlist[i].firstEdge; // 取 vi 边表的头指针 while(p){ // 依次搜索 vi 的邻接点vj， 这里 j=p-&gt;adjvex; if (!visited[p-&gt;adjvex]){ // 若 vj 尚未被访问 // 打印边 printf(&quot;(%c, %c)\n&quot;, G.vertex[i]-&gt;adjlist, G.vertex[p-&gt;adjvex]-adjlist); DFSTree(G, p-&gt;adjvex); } p = p-&gt;next; } } 2010 年线性表插入删除一个结点bool ListInsert(Sqlist &amp;L, int i, ElemType e){ // 本算法实现将元素 e 插入到顺序表 L 中第 i 个位置 if (i&lt;1 || i&gt;L.length+1) // 判断 i 的范围是否有效 return FALSE; if (L.length &gt;= MaxSize) //当前存储空间已满，不能插入 return FALSE; for (int j=L.length; j&gt;=i; j--) // 将第 i 个元素及之后的元素后移 L.data[j] = L.data[j-1]; L.data[i-1] = e; // 在位置 i 处放入 e L.length++; return TRUE; } bool ListDelete(Sqlist &amp;L, int i, int &amp;e){ // 本算法实现删除顺序表 L 中第 i 个位置的元素 if (i&lt;1 || i&gt;L.length) // 判断 i 的范围是否有效 return FALSE; e = L.data[i-1]; // 在位置 i 处放入 e for (int j=i; j&lt;L.length; j++) // 将第 i 个位置之后的元素前移 L.data[j-1] = L.data[j]; L.length--; return TRUE; } *二叉排序树采用二叉链表存储，删除结点值 X 的结点。删除后仍为二叉排序树（不考虑 X为根）思路：先用层次遍历思想查找到值为 X 的结点， 然后根据其是否有左右孩子情况删除处理。如果无左孩子，直接将右子树代替它。同理如果没有右孩子，直接将左子树代替它。如果左右孩子都存在，边在左子树中找一个值最大的结点代替它。 int DeleteBST (BiTree &amp;T, ElemType X){ // 删除二叉排序树 T 中，结点值为 X 的结点 if (!T) return 0; //不存在这样的结点 else{ if (X==T.key) return Delete(T); else if (X&lt;T.key) return DeleteBST(T-&gt;lchild, X); else return DeleteBST(T-&gt;rchild, X); } } int Delete(BiTree &amp; p){ // 从二叉树排序树中删除结点 p，并且重接他的左或右子树 if (!p-&gt;rchild){ // 右子树为空，只需重接左子树 q = p; p = p-&gt;lchild; free(q); } else if (!p-&gt;rchild){ // 左子树为空，只需要重接右子树 q = p; p = p-&gt;rchild; free(q); } else{ // 左右子树均不空 q = p; s = p-&gt;lchild; while (s-&gt;rchild){ // 找到左子树中结点值最大的结点 s q = s; s = s-&gt;rchild; } p-&gt;key = s-&gt;key; if (q != p) q-&gt;rchild = s-&gt;lchild; else q-&gt;lchild = s-&gt;lchild; free(s); } return 1; } *设 X 和 Y 是表示成单链表的两个串，找出 X 中第一个不在 Y 中出现的字符采用带头结点的单链表作为串的存储结构，找出 X 中第一个不在 Y 中出现的结点的算法 char find(LinkList X, LinkList Y){ LNode* p = X-&gt;next, *q; while(p){ // 遍历 Y，查找是否存在值为 p-&gt;data 的结点 q = Y-&gt;next; while(q){ if (p-&gt;data == q-&gt;data) break; else q = q-&gt;next; } if (!q) return p-&gt;data; // Y 中没有找到 else p = p-&gt;next; // Y 中找到，继续查找下一个元素 } } 2011 年求带头结点的单链表 L 中所含元素的个数，并给出单链表的数据结构示意图int CountNode(LinkList L){ int count = 0; LNode * p = L-&gt;next; while(p){ count++; p = p-&gt;next; } return count; } # 示意图： # # A-&gt;B-&gt;C...-&gt;N 递归函数求二叉树的高度int Height(BiTree T){ if (T == NULL) return 0; int ld = Height(T-&gt;lc); int rd = Height(T-&gt;rc); return (ld&gt;rd ? ld+1 : rd+1); } 2012 年*对一棵孩子 - 兄弟链表示的树统计其叶子的个数思路：采用还在兄弟链表示的树 T，对其从所有结点进行遍历。在访问结点是判定当前结点是否有孩子，如果没有孩子则该结点是叶子结点，计数器加一，遍历结束后，就能得到叶子结点数。 int CountLeafNode(CSTree T){ static int count = 0; if (T){ if (!T-&gt;firstchild){ count++; } else{ CountLeafNode(T-&gt;nextsibling); } return count; } } *查找值为 X 的结点（二叉树中）。用 C 语言打印值为 X 的结点的所有祖先并分析时间复杂度思路：采用非递归后序遍历，最后访问根节点，当访问到值为 x 的结点时，栈中所有元素均为该节点的祖先。因为采用的是后序遍历算法，故时间复杂度为O(n) void search(BiTree bt, ElemType x){ BiTree t; int tag; }stack; // tag = 0 表示左子树被方法，tag = 1 表示左子树被访问 void Search(BiTree bt, ElemType x){ // 在二叉树 bt 中，查找值为 x 的结点，并打印其所有祖先 stack s[]; top = 0; while (bt != NULL &amp;&amp; bt-&gt;data != x){ // 结点入栈 s[++top].t = bt; s[top].tag = 0; bt = bt-&gt;lchild; // 沿左分支向下 } if (bt-&gt;data == x){ printf(&quot;所查结点的所有祖先结点的值为:\n&quot;); // 找到 x for (i=1; i&lt;=top; i++){ // 输出祖先值后结束 printf(&quot;%d\n&quot;, s[i].t-&gt;data); exit(1); } } while (top != 0 &amp;&amp; s[top].tag == 1) // 退栈(空遍历) top--; if (top!=0){ s[top].tag = 1; bt = s[top].t-&gt;rchild; // 沿右分支向下遍历 } } *L1、L2为两循环单链表的头结点指针。m，n分别为数据结点个数。用最快速度将两表并成一个带头结点的循环单链表思路：采用头插法，将短链表插入到长链表中。时间复杂度为O(min(n, m)) void merge(LinkList &amp;L1, LinkList &amp;L2){ LinkList *p = L1-&gt;next, *q = L2-&gt;next; if (m&gt;n){ L3 = L1; L3-&gt;next = q; while (q-&gt;next != L2) q = q-&gt;next; q-&gt;next = p; free(L2); } else{ L3 = L2; L3-&gt;next = p; while (p-&gt;next != L1) p = p-&gt;next; p-&gt;next = q; free(L1) } } *求无向图 G （采用邻接表存储）的连通分量的个数思路：利用 DFS 算法一次遍历图中的一个连通分量，统计遍历完图总共调用 DFS 算法的次数即该图的连通块的个数。 // 从顶点 v 出发深度优先访问 G 的一个连通块 void DFS(Graph G, int v){ visited[v] = TRUE; // 标记访问 v 顶点 for (w=FirstAdjVex(G, v); w&gt;=0; w=NextAdjVex(G, v, w)){ if (!visited[w]) DFS(G, w); // 对 v 的尚未访问的邻接顶点调用 DFS 访问 } } int GetConnSubGraphNum(Graph G){ int count = 0; // 初始化访问标记数组 for (v=0; v&lt;G.vexnum; v++) visited[v] = FALSE; for (v=0; v&lt;G.vexnum; v++){ if (!visited[v]){ count++; // 连通块数量+1 DFS(G, v); } } return count; } 2013 年*给定二叉树 T 。统计二叉树 T 中结点的个数思路：一棵树的总结点数等于它的左子树上的结点数加上右子树上的节点数再加上其本身，空树的结点数为0，利用递归思想，求树 T 的总结点数 int CountNode (BiTree T){ if (T == NULL) return 0; // 空树的结点数为 0 else // 非空树结点数等于它的左子树上的结点数加上右子树上的结点数再加上其本身 return (1+CountNode(T-&gt;lc)+CountNode(T-&gt;rc)); } 2014 年*线性表（a1, a2, … , an）设计把所有偶数移动所有奇数前面。（时间最少，辅助空间最多）思路：采用快速排序思想，整个算法只需仿照快速排序的第一趟，只是判别条件不再是当前元素和枢轴值比较而是判断当前元素的奇偶性。时间复杂度O(n), 空间复杂度为O(1) void sheft(int *a, int n){ // 将长度为n的线性表a中的偶数移动到奇数前面 int temp = a[0]; int i = 0, j = n-1; // 记录当前区间的小标 while (i&lt;j){ while(i&lt;j &amp;&amp; a[j]%2!=0) j--; // 查找从前区间的最后面的一个偶数 a[i] = a[j]; // 将这个偶数移动到当前区间的最前面 while (i&lt;j &amp;&amp; a[i]%2 == 0) i++; // 查找从前区间的最前面的一个奇数 a[j] = a[i]; // 将这个奇数移动到当前区间的最后面 } a[i] = temp; } *求二叉树中以权值为 X 的 结点为根的子树的深度思路：求二叉树的深度可以递归求左右子树的深度，然后取其较大者加一 int getDeepth(BiTree T){ // 求二叉树 T 的深度 int ld, rd; if (T == NULL) return 0; // 空树 ld = getDeepth(T-&gt;lchild); rd = getDeepth(T-&gt;rchild); return (ld&gt;rd ?ld:rd)+1; } void visit(BiTree, int x){ // 对结点进行访问，如果结点权值为 x 时，打印以该节点的根的子树的深度 if (T-&gt;data == x){ printf(&quot;%d\n&quot;, getDeepth(T)); } } // 先序遍历二叉树 void preOrderVisit(BiTree T, int x){ if (T!=NULL){ visit(T, x); preOrderVisit(T-&gt;lchild); preOrderVisit(T-&gt;rchild); } } 2015 年*判断二叉树是否为二叉排序树思路：对于二叉排序树来说，其中序遍历序列为一个递增有序序列。因此，对给定的二叉树进行中序遍历，如果始终能保持前一个值比后一个值小，则说明该二叉树是一棵二叉排序树 KeyType predt = -32767; // predt 为全局变量。保存当前节点中序前驱的值 // 初值为负无穷 // 若二叉树 bt 是二叉排序树 jugedBST 返回值 1，否则返回 0 int JugedBST(BiTree bt){ int b1, b2; if (bt == NULL) // 空树 return 1; else{ b1 = JugedBST(bt-&gt;lchild); // 判断左子树是否是二叉排序树 if (b1==0 || predt&gt;=bt-&gt;data) // 若左子树返回值0或前驱大于等于当前节点 return 0; // 则不是二叉排序树 predt = bt-&gt;data; // 保存当前节点的关键字 b2 = JugedBST(bt-&gt;rchild); // 判断右子树 return b2; // 返回右子树的结果 } } *将无向图邻接矩阵转为对应的邻接表的算法思路： 首先初始化邻接表。遍历邻接矩阵，在遍历顶点 i 时，若发现v[i][j] 不等于 0 或无穷，则表示i, j有边，将这条边节点插入到邻接表的第i个表头节点之前。 int INF = 32767; // 全局变量表示无穷 void Convert(int G[N][N], ALGraph &amp;ALGraph){ // 此算法将邻接矩阵 G 转换为邻居表 ALGraph for (i=0; i&lt;N; i++){ for (i=0; j&lt;N; j++){ if (G[i][j]!=0 &amp;&amp; G[i][j]!=INF){ // 顶点 i 和 j 有边 ArcNode *p = (ArcNode*)malloc(sizeof(ArcNode)); // 创建边表节点 p p-&gt;adjvex = j; p-&gt;next = ALGraph[i].frist; // 将 p 插入顶点表节点之后 ALGraph[i].first = p; } } } } *给定图 G = (V, E) 其中 G 包含 n 个点和 m 条边。统计 G 中连通块分量的个数思路：由于深度优先搜素算法每次能遍历一个连通块，故只需统计调用 DFS 调用的次数即可。 int count = 0; // 全局变量，记录图G连通块的数目 bool visited[MAX_VERTEX_NUM]; // 访问标记数组 void CountConnectedBlock(Graph G){ // 该算法统计图 G 的连通块数目 for (v=0; v&lt;G.vexnum; v++) visited[v] = FALSE; // 初始化访问标记数组 for (v=0; v&lt;G.vexnum; v++){ // 如果没有访问，从该顶点出发，调用 DFS，访问该顶点所在的连通块，并将连通数量+1 if (!visited[v]){ count++; DFS(G, v); } } } void DFS(Graph G, int v){ // 从顶点 v 出发，采用递归思想，深度优先遍历图 G visit(v); // 访问顶点 v visited[v] = TRUE; // 设已访问标记、 for (w=FirstNeigbor(G, v); w&gt;=0; w=NextNeighbor(G, v, w)){ if (!visited[w]){ // w 为 v 的尚未访问邻接节点 DFS(G, w); } } } 2016 年*线性表元素递增，单链表存储。删除表中有值相同的多余元素并释放空间TODO *算法判别给定表达式中开括号是否配对出现TODO *给定二叉树 T 设计算法复制二叉树 TTODO *给图 G = (V, E) 和 G 中两个顶点 S, T 求一条顶点 t 到顶点 S 的简单路径TODO 2017 年*中序遍历二叉树 T (非递归)TODO *给定两个非空集合 A 和 B 分别用线性表 L1 和 L2 存储。算法求解 A∪BTODO 给定表达式 `A + B C - D | E后缀表达式为ABC *+ DE /-` 设计算法将原表达式转为为后缀表达式TODO *给定两棵树 T1 和 T2 判断 T1 与 T2 是否相同（二叉树）TODO 2018 年*计算两个多项式乘积（给定 La、Lb 两个带头结点单链表表示的多项式）TODO *给定二叉树，以先序形式输出所有结点的值和结点所在层次TODO]]></content>
      <categories>
        <category>知识储备</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI 模型分层作用及实例]]></title>
    <url>%2Fposts%2F4a1a5b83%2F</url>
    <content type="text"><![CDATA[应用层为应用程序提供服务并规定相关细节，包括文件传输（FTP）、电子邮件（SMTP）、远程登录（ssh、Telnet）等协议。 比如发送电子邮件，从用户输入完内容并点击“发送”的那一刻，就进入应用层协议处理了。协议会在数据首部添加收件人]]></content>
      <categories>
        <category>计算机网络相关</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法 Python 实现]]></title>
    <url>%2Fposts%2F576d991f%2F</url>
    <content type="text"><![CDATA[选择排序每一趟遍历把最小的依次放在最前面，时间复杂度O(n²) def select_sort(n): for i in range(len(n): min = i for j in range(i, len(n)): if n[min] &gt; n[j]: min = j if min != i: n[min], n[i] = n[i], n[min] return n 冒泡排序每一趟遍历把大的放前面，小的放后面，时间复杂度O(n²) def dubble_sort(n): for i in range(len(n)): for j in range(i+1, len(n)): if n[i] &gt; n[j]: n[i], n[j] = n[j], n[i] return n 插入排序在操作过程中维护一个排好序的片段，初始只包含一个元素。每次从未排序的片段取出一个元素插入正确的位置。时间复杂度为O(n²) def insert_sort(n): for i in (1, len(n)): x = n[i] j = i while j &gt; 0 and n[j-1] &gt; x: n[j] = n[j-1] j -= 1 n[j] = x return n 快速排序从数列中挑选出一个基准元素，把比基准小的放基准前，比基准大的放基准后。然后递归依次传入基准前后的序列。通常时间复杂度为O(nlogn)，最坏为O(n²)，当数列全相等、已经从小到大排好序或者从大到小排好序后为最坏情况 def sub_sort(array,low,high): key = array[low] while low &lt; high: while low &lt; high and array[high] &gt;= key: high -= 1 while low &lt; high and array[high] &lt; key: array[low], array[high] = array[high], array[low] low += 1 array[low] = key return low def quick_sort(array,low,high): if low &lt; high: key_index = sub_sort(array,low,high) quick_sort(array,low,key_index) quick_sort(array,key_index+1,high) a = [3,4,6,8,2,1,5,8,9] quick_sort(a, 0, len(a)-1) To Be Contune]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的魔术方法]]></title>
    <url>%2Fposts%2F22aee029%2F</url>
    <content type="text"><![CDATA[构造与初始化__new__(self): 创建并返回一个类的实例，而__init__只是将传入的参数来初始化该实例，一般不需要重载__new__方法除非希望控制类的创建。 __init__(self): 可以理解为构造函数，将传入的参数初始化成实例 __del__(self): 可以理解为析构函数 属性访问控制Python缺少对于类的封装,但人们希望Python能够定义私有属性，然后提供公共可访问的getter和 setter。 Python其实可以通过魔术方法来实现封装。 __getattr__(self, name): 该方法定义了你试图访问一个不存在的属性时的行为。因此，重载该方法可以实现捕获错误拼写然后进行重定向, 或者对一些废弃的属性进行警告。也可用于访问私有属性 __setattr__(self, name, value): 是实现封装的解决方案，它定义了你对属性进行赋值和修改操作时的行为。不管对象的某个属性是否存在,它都允许你为该属性进行赋值,因此你可以为属性的值进行自定义操作。有一点需要注意，实现__setattr__时要避免”无限递归”的错误。 def __setattr__(self, name, value): self.name = value # 每一次属性赋值时, __setattr__都会被调用，因此不断调用自身导致无限递归了。 正确为： def __setattr__(self, name, value): self.__dict__[name] = value]]></content>
      <categories>
        <category>知识储备</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见设计模式 Python 实现]]></title>
    <url>%2Fposts%2F7798fba3%2F</url>
    <content type="text"><![CDATA[简单工厂模式根据不同条件生产不同功能的类 class op(object): def get_ans(self): pass class Add(op): def get_ans(self): return self.a + self.b class Mul(op): def get_ans(self): return self.a * self.b class Undef(op): def get_ans(self): return &quot;UNDEF!&quot; class Factory(op): operator = dict() operator[&quot;+&quot;] = Add() operator[&quot;*&quot;] = Mul() def create_operator(self, ch): t = self.operator[ch] if ch in self.operator else Undef() return t if __name__ == &quot;__main__&quot;: a = int(input()) b = int(input()) op = input() factory = Factory() cal = factory.create_operator(op) cal.a = a cal.b = b print(cal.get_ans()) 单例模式单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类 “类 (计算机科学)”)必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 class Singleton: class __My_class: def __init__(self, arg): self.arg = arg def show(self): return (id(self), self.arg) _instance = None def __init__(self, arg): if not Singleton._instance: Singleton._instance = Singleton.__My_class(arg) else: Singleton._instance.arg = arg def __getattr__(self, attr): return getattr(self._instance, attr) if __name__ == &quot;__main__&quot;: s1 = Singleton(&quot;bar&quot;) s2 = Singleton(&quot;zoo&quot;) print(s1.show()) print(s2.show())]]></content>
      <categories>
        <category>知识储备</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2Fposts%2F5fddf106%2F</url>
    <content type="text"><![CDATA[Git 简介Git - 分布式版本控制系统，每台电脑上都可以离线存一个仓库，但总是设立一台服务器作为远程库SVN - 集中式版本控制系统，无本地仓库，push pull 必须通过中央服务器 基本操作git init # 初始化，创建仓库 git add . # 添加所有文件（添加单一文件写文件名）到缓存区 git commit -m &quot;message&quot; # 将缓存区所有任务保存到仓库，并添加本次修改的信息（注释） git status # 查看当前仓库状态，会显示无修改、有修改但未提交缓存、提交缓存但未提交仓库多种状态 git diff &lt;filename&gt; # 查看当前文件与最新版本的差异 git log # 显示历史记录 git log --pretty=oneline # 一行显示历史记录（显示全部id） git log --oneline # 一行显示历史记录（显示id前7位） git reflog # 显示所有命令记录 git log --graph # 显示分支合并图 git reset --hard &lt;commit ID&gt; # 退回某一版本，HEAD为最新版本 git checkout -- &lt;filename&gt; # 丢弃缓存区某文件的修改 git rm &lt;filename&gt; # 删除某文件并提交到缓存区 git tag v1.0 # 给最新commit创建tag git tag v0.9 f52c633 # 给f52c633创建tag v0.9 git tag -d v1.0 # 删除这个tag 远程库&amp;分支管理git remote add &lt;name(origin)&gt; git@github.com:ewdager/learngit.git # 从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联 git push -u origin master # 由于远程库是空的，我们第一次推送master分支时，加上了-u参数， # Git不但会把本地的master分支内容推送的远程新的master分支， # 还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 git clone git@github.com:ewdager/learngit.git # 克隆版本库 git checkout -b dev # 创建dev分支并切换，等于一下两条命令 git branch dev # 创建dev分支 git checkout dev # 切换至dev分支 git branch # 查看当前分支 git nerge dev # 把dev分支合并到master git branch -d dev # 删除dev分支 git merge --no-ff -m &quot;merge with no-ff&quot; dev # 强制禁用Fast forward模式，Git就会在merge时生成一个新的commit。删除分支后，不会丢掉分支信息 git stash # 储存当前“状态”，供后续恢复，不会影响缓存区和仓库 git stash list # 查看储存列表 git stash apply &lt;stashid&gt; # 恢复某次状态 git stash drop &lt;stashid&gt; #删除某次状态 git stash pop &lt;stashid&gt; # 恢复并删除某次状态 git branch -D &lt;name&gt; # 强制删除没被合并过的分支 git rebase # 让分支变得更美观！ 高级一点的操作 文件已修改，未add到缓存区: git checkout -- &lt;filename&gt; 文件已修改，并add到缓存区未commit： git reset HEAD &lt;filename&gt; git checkout -- &lt;filename&gt; 生成SSH KEY ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 其中id_rsa为私钥，id_rsa.pub为公钥。 当合并分支出现冲突时 先用git status查看冲突文件，然后手动修改冲突文件，最后将冲突文件add、commit即可合并成功。可用git log --graph查看分支合并图。 临时 Bug 分支&amp;保存现场 详见廖雪峰Git教程-Bug分支 多人协作 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 全文参考廖雪峰老师Git教程]]></content>
      <categories>
        <category>知识储备</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慎用 Python list 乘法]]></title>
    <url>%2Fposts%2F995b78a8%2F</url>
    <content type="text"><![CDATA[误用 list 乘法今天刷 LeetCode 碰到一个水题转置矩阵, 这不就是先生成个空的倒置矩阵再填结果嘛，没多想就用 list 乘法上手就写。 class Solution: def transpose(self, A): &quot;&quot;&quot; :type A: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; x, y = len(A), len(A[0]) buff =[[0] * x] * y for i in range(x): for j in range(y): buff[j][i] = A[i][j] return buff 看似结果非常正确，但是样例输出了一个很奇怪的结果。 我的输入: [[1,2,3],[4,5,6]] 我的答案: [[3,6],[3,6],[3,6]] 标准答案： [[1,4],[2,5],[3,6]] 赶紧在第12行前加上print(buff)一看 我的输入: [[1,2,3],[4,5,6]] 标准输出： [[0, 0], [0, 0], [0, 0]] [[1, 0], [1, 0], [1, 0]] [[2, 0], [2, 0], [2, 0]] [[3, 0], [3, 0], [3, 0]] [[3, 4], [3, 4], [3, 4]] [[3, 5], [3, 5], [3, 5]] 我的猜测与验证发现果然列表里的每一个子元素都相等了，猜测可能是 只复制了值的引用，而不是新建了一个对象,接下来就是验证。 &gt;&gt;&gt; a = [[0]*6]*4 &gt;&gt;&gt; a [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]] &gt;&gt;&gt; id(a[0]) 1423765355080 &gt;&gt;&gt; id(a[1]) 1423765355080 发现不出所料果然是这样。 正确姿势list 的乘法是能很方便的构建一个全为重复元素的一维列表方法，但在多维情况下非常容易出错。 所以说慎用 list 乘法！！！想构建 list 老老实实给我用列表生成器去。不要嫌写的太多不 pythonic class Solution: def transpose(self, A): &quot;&quot;&quot; :type A: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; x, y = len(A), len(A[0]) buff =[[0 for i in range(x)] for i in range(y)] for i in range(x): for j in range(y): buff[j][i] = A[i][j] return buff]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 单链表实现&基础函数]]></title>
    <url>%2Fposts%2F2870634a%2F</url>
    <content type="text"><![CDATA[前两天面滴滴，被问到怎么判断两个链表是否相交，然后并不懂什么是单链表相交…就很尴尬。 赶紧复习一下单链表的知识。 单链表实现class LNode: def __init__(self, elem, next_ = None): self.elem = elem self.next = next_ class LList: def __init__(self): self._head = None def is_empty(self): return self._head is None # 前端插入 def prepend(self, elem): self._head = LNode(elem, self._head) # 删除头结点并返回 def pop_first(self): if self.is_empty(): raise LinkedListUnderFlow(&quot;in pop&quot;) e = self._head.elem self._head = self._head.next return e def append(self, elem): if self.is_empty(): self._head = LNode(elem) return p = self._head while p.next: p = p.next p.next = LNode(elem) def pop(self): if self.is_empty(): raise LinkedListUnderFlow(&quot;in pop&quot;) p = self._head if p.next is None: e = p.elem self._head = None return e # 用p.next.next做条件是因为把最后一个结点删除，需要找到倒数第二个结点 while p.next.next is not None: p = p.next e = p.next.elem p.next = None return e def find(self, pred): p = self._head while p.next is not None: if pred(p.elem): # 构建生成器，找到了一个元素可以继续找下一个 yield p.elem p = p.next def printall(self): p = self._head while p is not None: print(p.elem, end=&quot;&quot;) if p.next is not None: print(&quot;, &quot;, end=&quot;&quot;) p = p.next # 换行，因为默认end参数为 &quot;\n&quot; # 等价 print(&quot;\n&quot;, end=&quot;&quot;) print(&quot;&quot;) if __name__ == &#39;__main__&#39;: my_list = LList() for i in range(10, 0, -1): my_list.prepend(i) my_list.printall() # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 for i in range(11, 21): my_list.append(i) my_list.printall() print(my_list.pop()) # 20 print(my_list.pop_first()) # 1 my_list.printall() # 2~19 def find_odd(n): if n % 2 != 0: return n for i in my_list.find(find_odd): print(i) # 1, 3, 5, 7, 9 ,... 补充一下print的参数 print(value, …, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False) sep: 多个参数之间的分隔字符串 end: print结束后的字符串 file: 输出到已打开的文件，注意，当文件关闭后才会保存 flush: 所有数据打印到控制台，立即“刷新”到实际控制台并保留待处理的打印缓冲区可用于上面的文件操作，当文件未关闭时及时输出到控制台，参考Stack Overflow]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编码</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Readfree 自动签到 & crontab自动任务踩坑]]></title>
    <url>%2Fposts%2F2ba86c7b%2F</url>
    <content type="text"><![CDATA[自动签到 Python 脚本这部分没什么难度，主要是这个网站的cookies的Max-Age有31449600秒，大概1年的寿命，所以直接将存好的cookies用requests发一个get请求到验证地址就行。稍微修改了博主杨英明代码如下： import requests import time # 登录验证地址 check_url = &#39;http://readfree.me/accounts/checkin&#39; # 记录程序运行时的时间 fp = open(&#39;./auto_signon_readfree.log&#39;,&#39;a&#39;) ISOTIMEFORMAT=&#39;%Y-%m-%d %X&#39; curtime = time.strftime(ISOTIMEFORMAT, time.localtime(time.time())) print (&#39;at %s&#39;%curtime) fp.write(&#39;at %s\n&#39;%curtime) # 准备cookie print (&#39;准备cookie中……&#39;) fp.write(&#39;准备cookie中……\n&#39;) cookie_str = &#39;cookies here&#39; cookie = {} for line in cookie_str.split(&#39;;&#39;): name,value=line.strip().split(&#39;=&#39;,1) cookie[name]=value print (cookie) fp.write(&#39;%s\n&#39;%cookie) # 使用cookie访问网站 print (&#39;签到中……&#39;) fp.write(&#39;签到中……\n&#39;) res = requests.get(check_url,cookies=cookie) print (res) fp.write(&#39;%s\n\n&#39;%res) crontab 自动任务这一步确实是踩了不少坑，还是Linux知识太欠缺了。 几次失败 直接在crontab -e中加入指令0 1 * * * python3 ~/autoSign/autoSign_readfree/py不执行 更换python3绝对路径后依旧不执行 查看crontablog发现文件不存在 .py文件头部添加#!/usr/bin/env python3报错env: python\r: No such file or directory 几次尝试 1-2 几次修改后依旧无果，在尝试2的后依旧不执行，考虑用新自动任务输出hello到log检测crontab是否出错，发现crontab能正常运行，随后考虑修复3问题 经查询发现crontab是默认不开启log功能的，解决方法如下：修改rsyslog服务，将 /etc/rsyslog.d/50-default.conf 文件中的 #cron.* 前的 #删掉,再使用service rsyslog restart；重启rsyslog服务 查询log文件发现.py依旧不执行，只能剑走偏锋不直接在crontab中使用python3命令，遂使用4在python文件头部添加#!/usr/bin/env python3让crontab以类似运行.sh文件的形式打开.py。在使用chmod a+x autoSign_readfree.py修改权限后报错env: python\r: No such file or directory参考stackoverflow发现是脚本包含CR字符。shell将这些CR字符解释为参数。使用以下脚本去除CR字符: with open(&#39;autoSign_readfree.py&#39;, &#39;rb+&#39;) as f: content = f.read() f.seek(0) f.write(content.replace(b&#39;\r&#39;, b&#39;&#39;)) f.truncate() 成功！最后在crontab中添加命令0 1 * * * ./autoSign_readfree.py大功告成！(据说每条命令必须换行才能执行) 补充几个crontab小知识 添加crontab任务 crontab -e 查看crontab任务 crontab -l 使用实例 0 2 * * * /bin/sh backup.sh //每天 02:00 执行任务 0 5,17 * * * /scripts/script.sh //每天 5:00和17:00执行任务 * * * * * /scripts/script.sh //每分钟执行一次任务 0 17 * * sun /scripts/script.sh //每周日 17:00 执行任务 */10 * * * * /scripts/monitor.sh //每 10min 执行一次任务 * * * jan,may,aug * /script/script.sh //在特定的某几个月执行任务 0 17 * * sun,fri /script/scripy.sh //在特定的某几天执行任务 0 2 * * sun [ $(date +%d) -le 07 ] &amp;&amp; /script/script.sh //在某个月的第一个周日执行任务 * * * * * sleep 30; /scripts/script.sh //每个30秒执行一次任务 * * * * * /scripts/script.sh; /scripts/scrit2.sh //多个任务在一条命令中配置 @reboot /scripts/script.sh //系统重启时执行]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Linux</tag>
        <tag>小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests 代理问题]]></title>
    <url>%2Fposts%2F7c092ea%2F</url>
    <content type="text"><![CDATA[在给一个本地的Flask项目测试post接口时遇到一个问题，无论用requests的get还是post请求localhost全部都会超时。 经过仔细分析后，发现是开了系统代理的锅(毕竟写代码少不了Google)，然而直接关闭系统代理仍然超时。 最后的解决方案如下： import os import requests os.environ[&#39;NO_PROXY&#39;] = &#39;127.0.0.1&#39; r = requests.get(&#39;http://127.0.0.1:5000&#39;) print(r.content) 设置不走代理的url，而不是直接把请求的proxies设置为本地代理！ 参考： stackoverflow: requests-how-to-disable-bypass-proxy stackoverflow: python-requests-return-504-in-localhost github: Issues with HTTP proxy and accessing localhost - does requests ignore no_proxy?]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 元组解包的几种方法]]></title>
    <url>%2Fposts%2Fbba523e0%2F</url>
    <content type="text"><![CDATA[访问下标解包这其实都不算解包了吧。。 &gt;&gt;&gt; a = (1,2,3) &gt;&gt;&gt; a[0] 1 赋值解包&gt;&gt;&gt; a = (1,2,3,) &gt;&gt;&gt; b, c, d = a 星号(*)解包要将一个tuple中的所有值作为参数，如果直接用上面两种方法就不太 pythonic了，可以用以下方法解包 ... &gt;&gt;&gt; brith = (2018, 7, 5,) &gt;&gt;&gt; datetime.date(brith) # 当然这里直接传入元组是不行的，该函数要求传入int类型 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: an integer is required (got type tuple) 所以正确的应该是 &gt;&gt;&gt; import datetime &gt;&gt;&gt; brith = (2018, 7, 5,) &gt;&gt;&gt; print(datetime.date(*brith)) # 注意*号 2018-7-5 来源: what-is-the-pythonic-way-to-unpack-tuples]]></content>
      <categories>
        <category>LeetCode刷题总结</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 部署(Apache)]]></title>
    <url>%2Fposts%2F725a38d2%2F</url>
    <content type="text"><![CDATA[安装sudo apt-get install python2.7.12 // 安装对应版本python sudo apt-get install apache2 // 安装apache sudo apt-get install libapache2-mod-wsgi // 安装apache的wsgi组件 sudo apt-get install pip // 安装python包管理 如果项目内有requrements.txt文件，进行如下操作安装项目依赖 pip install -r requrements.txt 配置 Apache首先将django项目放入/var/www/目录下，然后修改/etc/apache2/site-enabled/000-default.conf/文件 &lt;VirtualHost *:80&gt; ...略... # 配置python环境的路径，此处已系统环境为例 WSGIDaemonProcess Score python-path=/var/www/Score:/usr/bin/python/lib/python2.7/site-packages WSGIProcessGroup Score WSGIScriptAlias / /var/www/Score/Score/wsgi.py # 配置django静态文件目录 Alias /static/ /var/www/Score/ScoreQuery/static/ &lt;Directory /var/www/Score/ScoreQuery/static/&gt; Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 收集 Django 静态文件进入manage.py目录输入 python manage.py collectstatic 更改项目读写权限chown -R www-data:www-data /var/www/Score 重启 Apacheservice apache2 restart]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Web框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个简单二叉树的 Python 实现]]></title>
    <url>%2Fposts%2F3eeec910%2F</url>
    <content type="text"><![CDATA[二叉树的基本实现 class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 617.合并二叉树 class Solution: def mergeTrees(self, t1, t2): &quot;&quot;&quot; :type t1: TreeNode :type t2: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not t1: return t2 if not t2: return t1 t1.val += t2.val t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) return t1 104.二叉树的最大深度 class Solution: def maxDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root == None: return 0 ldepth = Solution.maxDepth(self, root.left) rdepth = Solution.maxDepth(self, root.right) return max(ldepth, rdepth) + 1 108.将有序数组转换为二叉搜索树 class Solution: def sortedArrayToBST(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; if len(nums) == 0: return None if len(nums) == 1: return TreeNode(nums[0]) if len(nums) == 2: tree = TreeNode(nums[1]) tree.left = TreeNode(nums[0]) return tree root = len(nums)//2 tree = TreeNode(nums[root]) tree.left = self.sortedArrayToBST(nums[0:root]) tree.right = self.sortedArrayToBST(nums[root+1:]) return tree]]></content>
      <categories>
        <category>LeetCode刷题总结</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 蛋疼的编码问题]]></title>
    <url>%2Fposts%2F7ed6f334%2F</url>
    <content type="text"><![CDATA[Python 的编码问题早就困扰我太久了， 但一直没有看到比较通俗易懂的专门介绍 Python 编码问题的文章。 正好今天刷知乎看到了非常不错的文章， 这里稍微抛砖引玉归纳下。 Unicode 和 UTF-8知识储备： ASCII 占1个字节，只支持英文 GBK GB2312的升级版，支持21000+汉字 Shift-JIS 日本字符 ks_c_5601-1987 韩国编码 TIS-620 泰国编码 由于每个国家都有自己的字符，所以其对应关系也涵盖了自己国家的字符，但是以上编码都存在局限性，即：仅涵盖本国字符，无其他国家字符的对应关系。 应运而生出现了万国码(Unicode)，他涵盖了全球所有的文字和二进制的对应关系。 Unicode解决了字符和二进制的对应关系，但是使用unicode表示一个字符，太浪费空间。例如：利用unicode表示“Python”需要12个字节才能表示，比原来ASCII表示增加了1倍。 由于计算机的内存比较大，并且字符串在内容中表示时也不会特别大，所以内容可以使用unicode来处理，但是存储和网络传输时一般数据都会非常多，那么增加1倍将是无法容忍的！！！ 为了解决存储和网络传输的问题，出现了Unicode Transformation Format，学术名UTF，即：对unicode中的进行转换，以便于在存储和网络传输时可以节省空间! UTF-8： 使用1、2、3、4个字节表示所有字符；优先使用1个字符、无法满足则使增加一个字节，最多4个字节。英文占1个字节、欧洲语系占2个、东亚占3个，其它及特殊字符占4个 UTF-16： 使用2、4个字节表示所有字符；优先使用2个字节，否则使用4个字节表示。 UTF-32： 使用4个字节表示所有字符； 总结： UTF 是为unicode编码设计的一种在存储和传输时节省空间的编码方案。 编码的转换对于历史遗留的以 GBK 编码编写的程序，我们可以不将其重新编码成 UTF-8 让其在没有安装 GBK 编码的终端上不乱码。 因为 Unicode 包含它与所有国家编码的映射关系， 所有只需要把数据从硬盘读到内存里， 转成 Unicode 来显示就可以了。由于所有的系统、编程语言都默认支持unicode，那你的gbk软件放到美国电脑 上，加载到内存里，变成了unicode,中文就可以正常展示啦。 Python3 的执行过程在看实际代码的例子前，我们来聊聊，python3 执行代码的过程 解释器找到代码文件，把代码字符串按文件头定义的编码加载到内存，转成unicode 把代码字符串按照语法规则进行解释， 所有的变量字符都会以unicode编码声明 编码转换过程在 py2 和 py3 下分别运行下面这段程序 # coding: utf-8 s = &#39;你好&#39; print(s) Python3: &#39;你好&#39; Python2: &#39;浣犲ソ&#39; 好了，这里就是最恶心的 Python2 的编码问题了。 这里使用的是 Windows cmd 默认的 GBK 编码运行的程序。 为什么py3正常，py2就显示二进制字节了呢。 因为到了内存里 python3 解释器把 utf-8 转成了 Unicode，而 python2 的默认编码是 ASCII ，py2 解释器仅以文件头声明的编码去解释这段代码， 加载到内存后，并不会主动转成 Unicode ，也就是说你的文件编码是以 utf-8 的信使加载到内存的， 所以是乱码。 在 Windows 上，字符串只有以GBK格式显示或者编码是Unicode才能正常显示。 这种情况，只能自己手动decode成 Unicode 了。 UTF-8 –&gt; decode 解码 –&gt; UnicodeUnicode –&gt; encode 编码 –&gt; GBK / UTF-8 .. # coding: utf-8 s = &#39;你好&#39; s2 = s.decode(&#39;utf-8&#39;) print(s2) # 你好 print(typr(s2)) # &lt;type &#39;unicode&#39;&gt; s3 = s2.encode(&quot;GBK&quot;) print(s3) # 你好 print(type(s3)) # &lt;type &#39;str&#39;&gt; 如何验证编码转对了呢？ 查看数据类型， python2里有专门的 Unicode 类型 查看 Unicode 编码映射表 unicode字符是有专门的unicode类型来判断的，而 utf-8, gbk 编码的字符都是str。 python bytes 类型Python2： &gt;&gt;&gt; s = &quot;你好&quot; &gt;&gt;&gt; print s 你好 &gt;&gt;&gt; s &#39;\xc4\xe3\xba\xc3&#39; &gt;&gt;&gt; s.decode(&#39;GBK&#39;) # CMD 编码格式为 GBK u&#39;\u4f60\u597d&#39; # 在 Unicode 编码表中对应的位置 首先， python2 是以 bytes 形式存储非英文字符串，所以bytes类型就是str &gt;&gt;&gt; s = &#39;你好&#39; &gt;&gt;&gt; type(s) &lt;type &#39;str&#39;&gt; Python3 的变革Python3 中终于把字符串的编码从 ASCII 改为了 Unicode ，并且把str和bytes做了明确的区分，str就是 Unicode 格式的字符， bytes就是单纯的二进制。 但是把 Unicode 编码成 GBK 后，字符串变成了bytes格式。 可能这是为了告诉你想在py3里看字符，必须得是unicode编码，其它编码一律按bytes格式展示。 &gt;&gt;&gt; s = &#39;你好&#39; &gt;&gt;&gt; s &#39;你好&#39; &gt;&gt;&gt; s2 = s.encode(&#39;GBK&#39;) &gt;&gt;&gt; s2 b&#39;\xc4\xe3\xba\xc3&#39; &gt;&gt;&gt; type(s2) &lt;class &#39;bytes&#39;&gt; 原文出自文章链接作者知乎用户：Alex-金角大王 这位大神写的太好了，这篇归纳都差不多算是照着原文重打一遍了。。。]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python2</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 查漏补缺之字符串]]></title>
    <url>%2Fposts%2F4be7f132%2F</url>
    <content type="text"><![CDATA[count 方法str.count(sub, start= 0,end=len(string)) 参数 sub – 搜索的子字符串 start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。 end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。 返回值 该方法返回子字符串在字符串中出现的次数。 LeetCode 相关题目 461. 汉明距离最优解法 class Solution: def hammingDistance(self, x, y): return(bin(x^y).count(&#39;1&#39;))]]></content>
      <categories>
        <category>LeetCode刷题总结</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中进制互换]]></title>
    <url>%2Fposts%2F8924f3f8%2F</url>
    <content type="text"><![CDATA[十进制转二进制bin() 返回一个整数 int 或者长整数 long int 的二进制表示。 &gt;&gt;&gt;bin(10) &#39;0b1010&#39; &gt;&gt;&gt; bin(20) &#39;0b10100&#39; 二进制转十进制&gt;&gt;&gt;int(&#39;0b1010&#39;, 2) &#39;10&#39; &gt;&gt;&gt;int(&#39;0b10100&#39;, 2) &#39;20&#39; LeetCode 相关题目 476. 数字的补数给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意: 给定的整数保证在32位带符号整数的范围内。 你可以假定二进制数不包含前导零位。 示例1： 输入: 5输出: 2解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。 示例2： 输入: 1输出: 0解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。 我的解法（83.7%）：暴力解法，把数字转换成二进制字符串去掉0b， 用遍历的方法取字符串补码， 再转回十进制数。 class Solution: def findComplement(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; str_num = str(bin(num))[2:] anti_num = [] for e, i in enumerate(str_num): if i == &#39;0&#39;: anti_num.append(&quot;1&quot;) else: anti_num.append(&quot;0&quot;) anti_num.insert(0, &quot;0b&quot;) anti_num = &quot;&quot;.join(anti_num) return int(anti_num, 2) 最优解：class Solution: def findComplement(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; n = len(bin(num))-2 return num^(2**n-1) 思路是，取出去除0b的二进制数‘长度’ n, 通过n求出num‘位数’全置1的十进制数， 在与num亦或即可得到补数。（补数的性质啊喂。。。这都没想出来）]]></content>
      <categories>
        <category>LeetCode刷题总结</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被忽略的位运算符总结]]></title>
    <url>%2Fposts%2Fef63884b%2F</url>
    <content type="text"><![CDATA[曾经的我还是太年轻了, 基础不扎实还自以为是, 看到位运算符一节就以为是逻辑运算, 结果跳过没看了, 漏了很多知识. 果然 LeetCode 没白刷呀, 接下来是总结. 按位与运算符（&amp;）参加运算的两个数据，按二进制位进行“与”运算。 运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; 即：两位同时为“1”，结果才为“1”，否则为0 例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 00000001 因此，3&amp;5的值得1。 另，负数按补码形式参加按位与运算。 “与运算”的特殊用途： 清零。如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 取一个数中指定位 方法：找一个数，对应X要取的位，该数的对应位为1，其余位为零，此数与X进行“与运算”可以得到X中的指定位。 例：设X=10101110，取X的低4位，用 X &amp; 0000 1111 = 00001110 即可得到； 还可用来取X的2、4、6位。 按位或运算符（|）参加运算的两个对象，按二进制位进行“或”运算。 运算规则：0|0=0; 0|1=1; 1|0=1； 1|1=1； 即： 参加运算的两个对象只要有一个为1，其值为1。 例如:3|5 即 00000011 | 0000 0101 = 00000111 因此，3|5的值得7。 另，负数按补码形式参加按位或运算。 “或运算”特殊作用： 常用来对一个数据的某些位置1。 方法：找到一个数，对应X要置1的位，该数的对应位为1，其余位为零。此数与X相或可使X中的某些位置1。 例：将X=10100000的低4位置1 ，用X | 0000 1111 = 1010 1111即可得到。 异或运算符(^)参加运算的两个数据，按二进制位进行“异或”运算。 运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 “异或运算”的特殊作用： 使特定位翻转找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。 例：X=10101110，使X低4位翻转，用X ^0000 1111 = 1010 0001即可得到。 与0相异或，保留原值 ，X ^ 00000000 = 1010 1110。 下面重点说一下按位异或,异或其实就是不进位加法,如1+1=0，,0+0=0,1+0=1。 异或的几条性质: 交换律 结合律（即(a^b)^c == a^(b^c)） 对于任何数x，都有x^x=0，x^0=x 自反性: a^b^b=a^0=a; 异或运算最常见于多项式除法，不过它最重要的性质还是自反性：A XOR B XOR B = A，即对给定的数A，用同样的运算因子（B）作两次异或运算后仍得到A本身。这是一个神奇的性质，利用这个性质，可以获得许多有趣的应用。 例如，所有的程序教科书都会向初学者指出，要交换两个变量的值，必须要引入一个中间变量。但如果使用异或，就可以节约一个变量的存储空间： 设有A,B两个变量，存储的值分别为a，b 则以下三行表达式将互换他们的值： a=a^b; b=b^a; a=a^b; 举例: 1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，能否设计一个算法实现？ 解法一、显然已经有人提出了一个比较精彩的解法，将所有数加起来，减去1+2+…+1000的和。这个算法已经足够完美了，相信出题者的标准答案也就是这个算法，唯一的问题是，如果数列过大，则可能会导致溢出。 解法二、异或就没有这个问题，并且性能更好。将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。 左移运算符（&lt;&lt;）将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 例：a = a&lt;&lt; 2将a的二进制位左移2位，右补0，左移1位后a = a * 2; 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。 右移运算符（&gt;&gt;）将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 操作数每右移一位，相当于该数除以2。 例如：a = a&gt;&gt; 2 将a的二进制位右移2位， 左补0 or 补1得看被移数是正还是负。 取反运算符 (~)按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 例如：a = 0011 1100 (61)(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 复合赋值运算符位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是： &amp;= 例：a &amp;=b 相当于a=a&amp; b |= 例：a |=b 相当于a=a |b >&gt;= 例：a &gt;&gt;=b 相当于a=a&gt;&gt; b &lt;&lt;= 例：a&lt;&lt;=b 相当于a=a&lt;&lt; b ^= 例：a ^= b 相当于a=a^ b 运算规则：和前面讲的复合赋值运算符的运算规则相似。 不同长度的数据进行位运算如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。 以“与”运算为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行“与”运算，右端对齐后，左边不足的位依下面三种情况补足， 如果整型数据为正数，左边补16个0。 如果整型数据为负数，左边补16个1。 如果整形数据为无符号数，左边也补16个0。 如：long a=123;int b=1;计算a&amp; b。 如：long a=123;int b=-1;计算a&amp; b。 如：long a=123;unsigned intb=1;计算a &amp; b。]]></content>
      <categories>
        <category>LeetCode刷题总结</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中in的三种遍历协议]]></title>
    <url>%2Fposts%2Fb7cb2971%2F</url>
    <content type="text"><![CDATA[今天刷LeetCode碰到个简单题 宝石与石头想降一下时间复杂度，就没有用in list写法，直接又遍历了一遍列表，可没想到一看答案，这样做的用时比用in要慢得多。索性研究了一下in的原理。这里复制一下知乎用户（很抱歉， 这位同学账号似乎被封了，无法著名）的答案。 in 关键字实现了一套python中的遍历协议. 协议A: iter + next 循环时, 程序先使用iter (相当于iter(instance))获取具有next方法的对象, 然后通过其返回的对象, 不断调用其next方法, 直到StopIteration错误抛出. class A: def __iter__(self): self.limit = 4 self.times = 0 self.init = 1 return self def next(self): if self.times &gt;= self.limit: raise StopIteration() else: x = self.init self.times += 1 self.init += 1 return x print &#39;A&gt;&gt;&gt;&gt;&gt;&gt;&#39; for x in A(): print x 打印结果： A&gt;&gt;&gt;&gt;&gt;&gt; 1 2 3 4 协议B: getitem + len 循环时, 程序先调用len (相当于len(instance))方法获取长度, 然后循环使用 getitem(index) (相当于instance[index])获取元素, index in range(len(instance)) class B: def __init__(self): self._list = [5, 6, 7, 8] def __getitem__(self, slice): return self._list[slice] def __len__(self): return len(self._list) print &#39;B&gt;&gt;&gt;&gt;&gt;&gt;&#39; for x in B(): print x 打印结果： B&gt;&gt;&gt;&gt;&gt;&gt; 5 6 7 8 协议C: yield关键字def C(): for x in range(9, 13): yield x print &#39;C&gt;&gt;&gt;&gt;&gt;&gt;&#39; for x in C(): print x 打印结果： C&gt;&gt;&gt;&gt;&gt;&gt; 9 10 11 12 从上边可以看出, ABC三种方式都可以实现in的循环, 对于A和B, 如果一个类把这两个方案都实现了怎么办? class D(A, B): pass print &#39;D&gt;&gt;&gt;&gt;&gt;&gt;&#39; for x in D(): print x 打印结果： D&gt;&gt;&gt;&gt;&gt;&gt; 1 2 3 4 可见, in优先使用的是A计划. 作者：知乎用户链接：https://www.zhihu.com/question/24868112/answer/83471042来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>LeetCode刷题总结</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次敏捷开发经历]]></title>
    <url>%2Fposts%2F7452c3b2%2F</url>
    <content type="text"><![CDATA[说的我自己都害羞…啥敏捷开发, 第一没有根据甲方需求持续迭代, 第二两个项目应该连正常项目都算不上, 顶多算个小练手. 但是确实是一周之内使用”敏捷”工具构建成的2333, 勉强就这么称呼吧, 反正这博客也就我自己看~ 使用ThinkPHP开发简单人事培养管理系统开始动工的时候时间还算充裕, 本打算采用Laravel进行开发, 但由于Laravel有些”重”, 还有这是第一次使用PHP来写一个相对完整的项目, 所以感觉时间有些紧迫. 权衡之下还是踩进了这个”中文文档完整, 国内社区活跃”的大坑. 使用的ThinkPHP版本是3.2.3, 是一个相对较老版本(这里就必须吐槽一下, 这版本的MVC结构相当混乱, 还使用了大量的单字母命名的方法使用起来相当难受). 好了言归正传, 说说开发经历. 毕竟是第一次使用PHP写项目时间还这么短, 不敢把功能写的太复杂, 整个项目只使用了简单的POST、 GET请求, 少量的session(仅用于验证登录) 剩下的就是几个数据库的操作了. 开发起来还是算比较舒畅的, 虽然造了几个简单的轮子但用时不算多, 三四天时间就基本完成了. 通过这个项目还稍稍补了点前端知识233. 不足的地方, 因为这个版本的ThinkPHP还是通过URL来判断使用哪个模块中的哪个方法, 而不是使用标准的路由. 导致整个项目异常的混乱, 我感觉除了我自己没人想来看这脏代码. 自我评级 项目用时: ★★★☆☆代码整洁: ★☆☆☆☆ 使用Django2.0开发简易水果电商首先庆祝Django终于升级到2.x了, 还有就是终于放弃支持py2了. 曾经用py2真是被那奇葩的编码问题坑的不要不要的. 用回熟悉的语言和熟悉的框架感觉就像是回了家一样:) 还有就是用了比较辣鸡的框架再用Django, 深深感受到优美的MVC结构是多么重要, 甚至让我感觉我是在用CMS建站. 好了好了不吹了…说说开发经历. 毕竟比较熟悉Django那套流程, 商城的登录注册就用Auth模块实现, 商品分页就是paginator模块, 购物车、订单就自己造个轮子实现(其实可以使用第三方库Cart实现, 不过总觉得这样就太过分了, 自己算是啥都没写, 代码量少的不敢提交Github). 整个流程一气呵成, 一天之内全部搞定, 不愧是python热度最高的框架. 自我评级 项目用时: ★★★★☆代码整洁: ★★★★☆ 小结虽然吹了那么久Django, 但是还是觉得这样”偷懒”并不适合现阶段的我… 毕竟 没学到什么东西啊!还没去找实习啊!!只会点框架找毛工作啊!!!还不造轮子!!!!只晓得偷懒用别人的!!!!!计算机网络看了吗? 操作系统会了吗? LeetCode刷完了吗? 咳咳..我还是去学基础吧…]]></content>
      <categories>
        <category>不知道怎么归类</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于域名解析的另一个吐槽]]></title>
    <url>%2Fposts%2Fbd4cc0f1%2F</url>
    <content type="text"><![CDATA[今天翻github惊奇的发现，我这个辣鸡博客竟然被@兴栋大佬的博客做了友链。不胜惶恐，但发现友链是之前没填坑的无法访问的裸域名，所以这个坑必须赶紧填啊。之前TX云送的学生cdn+域名解析中@记录和www记录都是设置的CNAME跳转到cdn。。结果访问gvoidy.cn出现404，简直神奇。试过很多次之后还是不行，不知道这是什么鬼。。最后解决方法还是把@记录重定向到https://www.gvoidy.cn 上才解决。有点迷。先留坑以后再研究是什么操作。 2.21 21:00 Update 今天Github发了个邮件过来说我CNAME文件配置的有问题。。结果我一看。woc当时CNAME文件竟然配置的是www.gvoidy.cn。。怪不得访问gvoidy.cn没用。emmm算是完了一个坑吧。。 2.21 21:36 Update again 再次更新。按照上面那个思路设置以后不管gvoidy.cn还是https://www.gvoidy.cn 全都无法访问了。 好吧。确实是域名解析的相关知识不太熟悉导致进了这个坑。因为这个域名下弄了邮箱做了MX记录。MX记录与CNAME记录同时共存会出现一些问题。比如邮件收不到，CNAME又失败等。所以最开始的把gvoidy.cn这个@记录做成重定向的思路是对的。Github那边发邮件是因为我CNAME文件中配置的是www.gvoidy.cn而设置中又是gvoidy.cn所以才会出现错误。但是其实我域名解析那边把gvoidy.cn是重定向到https://www.gvoidy.cn 这个域名的，所以一切正常。 知识补充： 递归DNS服务器在查询某个常规域名记录（非CNAME记录）时，如果在本地cache中已有该域名有对应的CNAME记录，则会开始用该别名记录来重启查询。上文中dig查询MX记录测试示例即对应于这种情况。 因此，即使某些域名解析系统网页上并未限制用户同时填写CNAME和MX的操作，但只要将CNAME和MX配置到一起，上述问题也一定是存在的，它会导致邮件服务偶尔出现异常。 实际上除了CNAME和MX不能共存外，已经注册了CNAME类型的域名记录是不能再注册除DNSSEC相关类型记录（RRSIG、NSEC等）之外的任何其他类型记录（包括MX、A、NS等记录）。理由同上，这里就不一一做演示了。]]></content>
      <categories>
        <category>不知道怎么归类</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始学Laravel]]></title>
    <url>%2Fposts%2F19653b91%2F</url>
    <content type="text"><![CDATA[Laravel5.5的安装安装好WAMP环境后，在wampmanager.ini文件中将PHP版本更改为php7，查看php版本可以通过phpinfo()函数查看。,下载好后解压至Apache工作目录下。启动wamp服务后，正常情况下访问localhost/laravel/public就能显示Laravel的欢迎界面。 附上Laravel一键安装包下载地址 PhpStrom安装编程还是离不开JB全家桶的~这步没有省略主要是因为jb全家桶更新3.4后大量激活方法和激活服务器集体失效。这里使用了ilanyu大佬提供的本地反向代理激活方法，或者自己手撸一个反代程序，不过比较麻烦的是每次打开IDE都需要进行授权认证，因此本地激活的IDE每次运行都需要启动一次反代程序，有条件最好挂在云服务器上。不过有条件还是要支持正版~ Laravel教程使用碰到的一些坑 vagrant下composer create-project laravel/laravel Laravel --prefer-dist &quot;5.5.*&quot;报错，解决方法：更换Composer国内镜像即可composer config -g repo.packagist composer https://packagist.phpcomposer.com Laravel的路由Laravel5.5版本中把路由的routes文件拿出来单独建立了一个routes文件。这里感觉和django的urls.py文件很类似，也是起到了Controller的作用，值得一提的是必须制定http请求类型 路由选项// 基础路由 Route::get(&#39;/&#39;, function () { return view(&#39;welcome&#39;); }); Route::post(&#39;test&#39;, function(){ return &#39;hello test&#39;; }); //多请求路由 Route::match([&#39;get&#39;, &#39;post&#39;], &#39;test2&#39;, function(){ return &#39;hello test2&#39;; }); Route::any(&#39;test3&#39;, function (){ return &#39;hello test3&#39;; }); 路由参数这里虽然写起来比django的要复杂，但是个人感觉比urls.py中的逻辑要清楚。 //路由参数 Route::get(&#39;user/{id}&#39;, function ($id){ return &#39;id &#39;. $id; }); Route::get(&#39;user/{name?}&#39;, function ($name = null){ return &#39;name &#39;. $name; }); Route::get(&#39;user/{id}/{name?}&#39;, function ($id, $name){ return &#39;id &#39;. $id. &#39; &#39;. &#39;name &#39;. $name; })-&gt;where([&#39;id&#39; =&gt; &#39;[0-9]+&#39;, &#39;name&#39; =&gt; &#39;[A-Za-z]+&#39;]); 路由命名命名的好处是可以直接通过命名之后的路由进行重定向，带参数的路由可以指定初始值，相当于给这个url一个名字,可以直接使用route()生成对应的url。 $app-&gt;get(&#39;user/{id}/profile&#39;, [&#39;as&#39; =&gt; &#39;profile&#39;, function ($id) { // }]); $url = route(&#39;profile&#39;, [&#39;id&#39; =&gt; 1]); 生成重定向 return redirect()-&gt;route(&#39;profile&#39;,1); 这样就会重定向到 user/1/profile; 路由群组这个相比django就比较代码上繁琐了，但是逻辑还是很好的 //此处为前缀群组 Route::group([&#39;prefix&#39; =&gt; &#39;member&#39;], function(){ Route::get(&#39;hello&#39;, function(){ return &#39;hello&#39;; }); Route::get(&#39;world&#39;, function(){ return &#39;world&#39;; }); }); 这个时候想显示hello时就不能直接访问hello，要访问member/hello 才行了]]></content>
      <categories>
        <category>PHP学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP学习小知识点归纳]]></title>
    <url>%2Fposts%2Fea2f965e%2F</url>
    <content type="text"><![CDATA[Heredoc结构形式长字符串 首先使用定界符表示字符串（&lt;&lt;&lt;），接着在“&lt;&lt;&lt;“之后提供一个标识符GOD，然后是字符串，最后以提供的这个标识符结束字符串。 &lt;?php $string1 = &lt;&lt;&lt;GOD 我有一只小毛驴，我从来也不骑。 有一天我心血来潮，骑着去赶集。 我手里拿着小皮鞭，我心里正得意。 不知怎么哗啦啦啦啦，我摔了一身泥. GOD; echo $string1; ?&gt; 单双引号区别 单引号串和双引号串在PHP中的处理是不相同的。双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符。 $str=&#39;hello&#39;; echo &quot;str is $str&quot;; //运行结果: str is hello echo &#39;str is $str&#39;; //运行结果: str is $str 资源类型 这里和python比较类似，不过还是留档一下。 &lt;?php //首先采用“fopen”函数打开文件，得到返回值的就是资源类型。 $file_handle = fopen(&quot;/data/webroot/resource/php/f.txt&quot;,&quot;r&quot;); if ($file_handle){ while (!feof($file_handle)) { //判断是否到最后一行 $line = fgets($file_handle); //读取一行文本 echo $line; //输出一行文本 echo &quot;&lt;br /&gt;&quot;; //换行 } } fclose($file_handle);//关闭文件 ?&gt; 空类型 php空类型是NULL且对大小不敏感，python中为None对大小写敏感。 常量 php中有常量这个概念！这点比没有常量概念的python好多了啊。 &lt;?php define(&quot;PI&quot;,3.14); $r=3; echo &quot;面积为:&quot;.(PI*$r*$r).&quot;&lt;br /&gt;&quot;; echo &quot;周长为:&quot;.(2*PI*$r).&quot;&lt;br /&gt;&quot;; ?&gt; 判断常量是否被定义 //bool defined(string constants_name) &lt;?php define(&quot;PI1&quot;,3.14); $p = &quot;PI1&quot;; $is1 =defined($p); $is2 = defined(&quot;PI2&quot;); var_dump($is1); // true var_dump($is2); // false ?&gt; 赋值运算符 类似c语言的取址，“&amp;”：引用赋值，意味着两个变量都指向同一个数据。它将使两个变量共享一块内存，如果这个内存存储的数据变了，那么两个变量的值都会发生变化。 $c = &amp;$a; 运算符 var_dump($a === $b); //全等 var_dump($a &lt;&gt; $b); //不等 返回bool var_dump($a !== $b); //非全等（类型+数据） $b = $a &gt;= 60 ? &quot;及格&quot;: &quot;不及格&quot;; // 三元运算符 连接运算符 和其他语言不一样，php使用”.”来连接字符串 $a = &quot;张先生&quot;; $tip = $a.&quot;,欢迎您在慕课网学习PHP！&quot;; $b = &quot;东边日出西边雨&quot;; $b .= &quot;,道是无晴却有晴&quot;; $c = &quot;东边日出西边雨&quot;; $c = $c.&quot;,道是无晴却有晴&quot;; 错误控制运算符 PHP中提供了一个错误控制运算符“@”，对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉； 如果激活了track_error（这个玩意在php.ini中设置）特性，表达式所产生的任何错误信息都被存放在变量$php_errormsg中，此变量在每次出错时都会被覆盖，所以如果想用它的话必须尽早检查。 需要注意的是：错误控制前缀“@”不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。 &lt;?php $conn = @mysql_connect(&quot;localhost&quot;,&quot;username&quot;,&quot;password&quot;); echo &quot;出错了，错误原因是：&quot;.$php_errormsg; ?&gt; foreach循环 只取值，不取下标 &lt;?php foreach (数组 as 值){ //执行的任务 } ?&gt; 同时取下标和值 &lt;?php foreach (数组 as 下标 =&gt; 值){ //执行的任务 } ?&gt;]]></content>
      <categories>
        <category>PHP学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小吐槽]]></title>
    <url>%2Fposts%2Fed36993e%2F</url>
    <content type="text"><![CDATA[哇，偷懒没弄https果然被流量劫持了，唉，只能开工加个https顺便优化一下因迁移产生的大量中文文章链接吧。 永久链接此处使用hexo-abbrlink插件实现。附上官方使用文档 安装npm install hexo-abbrlink --save使用打开config.yml，修改permalink中类似这样permalink: posts/:abbrlink/其中:abbrlink代表连接地址。 然后在所有文章加上abbrlink: 字段再部署后就会生成文章永久链接，方便SEO 为网站添加SSL证书 在source目录下创建一个CNAME文件（没有md后缀）,里面写入你的域名地址，不用带http/ https TX云开启CDN服务并申请SSL证书，CDN设置将回源设置为https并设置强制跳转https 不过这里出现了一个小问题，就是不能直接用域名访问了很不爽，必须使用www.gvoidy.cn才能访问。之后再优化吧~]]></content>
      <categories>
        <category>不知道怎么归类</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现单工、半双工、全双工聊天室]]></title>
    <url>%2Fposts%2F14572bdc%2F</url>
    <content type="text"><![CDATA[聊天室单工实现：单工版非常简单，只能客户端单方面向服务端发消息，服务端回复固定模板消息。 Server: # -*- coding: utf-8 -*- import socket import threading import time def tcplink(sock, addr): print &#39;Accept new connection from %s:%s...&#39; % addr sock.send(&#39;Welcome!&#39;) while True: data = sock.recv(1024) time.sleep(1) if data == &#39;exit&#39; or not data: break sock.send(&#39;Hello, %s!&#39; % data) sock.close() print &#39;Connection from %s:%s closed.&#39; % addr s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&#39;127.0.0.1&#39;, 9999)) s.listen(5) print &#39;Waiting for connection...&#39; while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start() Client: # -*- coding: utf-8 -*- import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立连接: s.connect((&#39;127.0.0.1&#39;, 9999)) # 接收欢迎消息: print s.recv(1024) for data in [&#39;Michael&#39;, &#39;Tracy&#39;, &#39;Sarah&#39;]: # 发送数据: s.send(data) print s.recv(1024) s.send(&#39;exit&#39;) s.close() 此为最基础的基于TCP协议的聊天程序，实现了Socket编程的主要流程。 服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 聊天室半双工实现：半双工实现是连接建立以后，服务器等待客户端发送消息，客户端发送消息后等待接收服务器，这样一来一回循环往复下去。直到出现quit，关闭连接。 Server: # -*- coding: utf-8 -*- import socket from time import ctime HOST = &#39;localhost&#39; PORT = 3300 BUSIZ = 1024 ADDR = (HOST, PORT) def closeTCnt(): TCntSock.close() print &quot;Session closing..&quot; TSerSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) TSerSock.bind(ADDR) TSerSock.listen(1) try: while True: print &#39;Waitting for connection...&#39; (TCntSock, cntAddr) = TSerSock.accept() print &#39;...connection from:&#39;, cntAddr try: while True: rData = TCntSock.recv(BUSIZ) if not rData: continue elif rData == &#39;quit&#39;: break else: print &#39;From [%s] %s \n %s&#39; % (cntAddr[0], ctime(), rData) while True: sData = raw_input(&#39;&gt; &#39;) if not sData: continue else: TCntSock.send(&#39;From [%s] %s \n %s&#39; % (cntAddr[0], ctime(), sData)) break except socket.error, detail: print detail closeTCnt() finally: TSerSock.close() Client: # -*- coding: utf-8 -*- import socket HOST = &#39;localhost&#39; PORT = 3300 BUFSIZ = 1024 ADDR = (HOST, PORT) tryCon = 0 def TCnt(): tcpCliSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) while True: try: tcpCliSock.connect(ADDR) except: print u&quot;正在尝试连接远程主机 &quot; global tryCon tryCon += 1 if tryCon == 3: print u&quot;无法连接上远程主机，请稍后再试&quot; exit() else: break print u&#39;登陆成功（通讯结束请输入&quot;quit&quot;退出）\n&#39; try: while True: data = raw_input(&#39;&gt; &#39;) if not data: continue elif data == &#39;quit&#39;: tcpCliSock.send(data) break else: tcpCliSock.send(data) while True: data = tcpCliSock.recv(BUFSIZ) if not data: continue else: print data break except socket.error, e: print &quot;Session closing&quot; print e tcpCliSock.close() if __name__ == &quot;__main__&quot;: TCnt() 这里就出现了一个有趣的问题，为什么这段代码只能一来一回的发送消息呢？讲道理应该发完消息不应该可以接着发消息吗？凭什么发了一条消息必须等待另一端发消息回来才能继续发？这就引出了全双工实现的原理。 聊天室全双工(P2P)实现：因为TCP连接是一个流，所以Socket模块的recv()是直到Scoket连接终断不会停止等待接受从另一端发送的消息的。全双工实现比半双工工多了个线程处理，所以服务器与客户端必须开两个线程，一个收消息一个发消息，并且发消息的线程需要阻塞收消息的线程。 Server: # -*- coding: utf-8 -*- from socket import * from time import ctime import threading import re HOST = &#39;&#39; PORT = 9999 BUFSIZ = 1024 ADDR = (HOST, PORT) tcpSerSock = socket(AF_INET, SOCK_STREAM) tcpSerSock.bind(ADDR) tcpSerSock.listen(5) clients = {} # username -&gt; socket chatwith = {} # user1.socket -&gt; user2.socket # clients字典中记录了连接的客户端的用户名和套接字的对应关系 # chatwith字典中记录了通信双方的套接字的对应 # messageTransform()处理客户端确定用户名之后发送的文本 # 文本只有四种类型： # None # Quit # To:someone # 其他文本 def messageTransform(sock, user): while True: data = sock.recv(BUFSIZ) if not data: if chatwith.has_key(sock): chatwith[sock].send(data) del chatwith[chatwith[sock]] del chatwith[sock] del clients[user] sock.close() break if data == &#39;Quit&#39;: sock.send(data) if chatwith.has_key(sock): data = &#39;%s.&#39; % data chatwith[sock].send(data) del chatwith[chatwith[sock]] del chatwith[sock] del clients[user] sock.close() break elif re.match(&#39;^To:.+&#39;, data) is not None: data = data[3:] if clients.has_key(data): if data == user: sock.send(&#39;Please don\&#39;t try to talk with yourself.&#39;) else: chatwith[sock] = clients[data] chatwith[clients[data]] = sock else: sock.send(&#39;the user %s is not exist&#39; % data) else: if chatwith.has_key(sock): chatwith[sock].send(&#39;[%s] %s: (%s)&#39; % (ctime(), user, data)) else: sock.send(&#39;Nobody is chating with you. Maybe the one talked with you is talking with someone else&#39;) # 每个客户端连接之后，都会启动一个新线程 # 连接成功后需要输入用户名 # 输入的用户名可能会： # 已存在 # (客户端直接输入ctrl+c退出) # 合法用户名 def connectThread(sock, test): # client&#39;s socket user = None while True: # receive the username username = sock.recv(BUFSIZ) if not username: # the client logout without input a name print(&#39;The client logout without input a name&#39;) break if clients.has_key(username): # username existed sock.send(&#39;Reuse&#39;) else: # correct username sock.send(&#39;OK&#39;) clients[username] = sock # username -&gt; socket user = username break if not user: sock.close() return print(&#39;The username is: %s&#39; % user) # get the correct username messageTransform(sock, user) if __name__ == &#39;__main__&#39;: while True: print(&#39;...WAITING FOR CONNECTION&#39;) tcpCliSock, addr = tcpSerSock.accept() print(&#39;CONNECTED FROM: &#39;, addr) chat = threading.Thread(target=connectThread, args=(tcpCliSock, None)) chat.start() Client: # -*- coding: utf-8 -*- from socket import * import threading HOST = &#39;127.0.0.1&#39; PORT = 9999 BUFSIZ = 1024 ADDR = (HOST, PORT) tcpCliSock = socket(AF_INET, SOCK_STREAM) tcpCliSock.connect(ADDR) &#39;&#39;&#39; 因为每个客户端接收消息和发送消息是相互独立的， 所以这里将两者分开，开启两个线程处理 &#39;&#39;&#39; def Send(sock, test): while True: try: data = raw_input() sock.send(data) if data == &#39;Quit&#39;: break except KeyboardInterrupt: sock.send(&#39;Quit&#39;) break def Recv(sock, test): while True: data = sock.recv(BUFSIZ) if data == &#39;Quit.&#39;: print(&#39;He/She logout&#39;) continue if data == &#39;Quit&#39;: break print(&#39; %s&#39; % data) if __name__ == &#39;__main__&#39;: print(&#39;Successful connection&#39;) while True: username = raw_input(&#39;Your name(press only Enter to quit): &#39;) tcpCliSock.send(username) if not username: break # username is not None response = tcpCliSock.recv(BUFSIZ) if response == &#39;Reuse&#39;: print(&#39;The name is reuse, please set a new one&#39;) continue else: print(&#39;Welcome! %s&#39; % username) break if not username: tcpCliSock.close() recvMessage = threading.Thread(target=Recv, args=(tcpCliSock, None)) sendMessage = threading.Thread(target=Send, args=(tcpCliSock, None)) sendMessage.start() recvMessage.start() sendMessage.join() recvMessage.join() 这里的实现逻辑是，每当一个客户端连接进服务端，客户端需要向服务端申请一个ID，服务端将这个ID与客户端连接的Socket对象存入字典，然后监听客户端向服务端发出的消息中有没有”To:”如果有就取出至三个字符后的字符，与字典中的key去比对，如果有存在的ID(不能是当前客户端自己的ID)，就将这两个Socket对象存入一个chatwith的字典中。实现A客户端发消息给服务端，服务端从chatwith字典中查询当前客户端对应的连接，再将A客户端的消息发送给连接的B客户端。 不过这里出现了一个问题，如果客户端A在和B聊天的过程中，进来了一个客户端C。客户端C也想加入AB的聊天，但是我们的服务端将C的Socket对象覆盖掉了B的，于是B发送什么消息A都接受不到了，而A发的消息只有C能收到了。 这里通过广播(P2M)的形式解决。 聊天室全双工(P2M)实现：这里稍微修改了P2P实现的服务端逻辑，不在将Socket连接一一对应，而是将所有的Socket连接存入一个列表，每当一个客户端发送消息，服务端就将这段消息广播给所有的客户端。 Server: # -*- coding: utf-8 -*- import socket, select host = socket.gethostname() port = 8080 addr = (host, port) inputs = [] fd_name = {} def who_in_room(w): name_list = [] for k in w: name_list.append(w[k]) return name_list def conn(): print &#39;...WAITING FOR CONNECTION&#39; ss = socket.socket() ss.bind(addr) ss.listen(5) return ss def new_coming(ss): client, add = ss.accept() print &#39;welcome %s %s&#39; % (client, add) wel = &#39;&#39;&#39;&#39;&#39;Your name(press only Enter to quit): &#39;&#39;&#39; try: client.send(wel) name = client.recv(1024) inputs.append(client) fd_name[client] = name nameList = &quot;Some people in talking room, these are %s&quot; % (who_in_room(fd_name)) client.send(nameList) except Exception, e: print e def server_run(): ss = conn() inputs.append(ss) while True: r, w, e = select.select(inputs, [], []) for temp in r: if temp is ss: new_coming(ss) else: disconnect = False try: data = temp.recv(1024) data = fd_name[temp] + &#39; say : &#39; + data except socket.error: data = fd_name[temp] + &#39; leave the room&#39; disconnect = True if disconnect: inputs.remove(temp) print data for other in inputs: if other != ss and other != temp: try: other.send(data) except Exception, e: print e del fd_name[temp] else: print data for other in inputs: if other != ss and other != temp: try: other.send(data) except Exception, e: print e if __name__ == &#39;__main__&#39;: server_run() Client: # -*- coding: utf-8 -*- import socket, select, threading host = socket.gethostname() addr = (host, 8080) def conn(): s = socket.socket() s.connect(addr) return s def lis(s): my = [s] while True: r, w, e = select.select(my, [], []) if s in r: try: print s.recv(1024) except socket.error: print &#39;socket is error&#39; exit() def talk(s): while True: try: info = raw_input() except Exception, e: print &#39;can\&#39;t input&#39; exit() try: s.send(info) except Exception, e: print e exit() def main(): ss = conn() t = threading.Thread(target=lis, args=(ss,)) t.start() t1 = threading.Thread(target=talk, args=(ss,)) t1.start() if __name__ == &#39;__main__&#39;: main() 聊天室全双工(P2M)WebSocket实现：这里又有一个奇思妙想出现了，因为在学习Socket编程的时候接触到了一个叫WebSocket的好玩的东西，于是实现了一个以浏览器为客户端的聊天室程序。使用Nodejs编写聊天室不仅代码简洁优雅功能强大，并且逼格都高很多。 此处以node.js + nodejs-websocket实现，首先需要安装Node.js和这个第三方模块 Server: var ws = require(&quot;nodejs-websocket&quot;) var clientCount = 0 // Scream server example: &quot;hi&quot; -&gt; &quot;HI!!!&quot; var server = ws.createServer(function (conn) { console.log(&quot;New connection&quot;) clientCount++ conn.nickname = &#39;user&#39; + clientCount broadcast(conn.nickname + &#39; comes in&#39;) conn.on(&quot;text&quot;, function (str) { console.log(&quot;Received &quot;+str) broadcast(conn.nickname + &quot;: &quot; + str) }) conn.on(&quot;close&quot;, function (code, reason) { console.log(&quot;Connection closed&quot;) broadcast(conn.nickname + &#39; left&#39;) }) conn.on(&quot;error&quot;, function(err) { console.log(&quot;handle err&quot;) console.log(err) }) }).listen(8001) console.log(&quot;connect is close&quot;); function broadcast(str){ server.connections.forEach(function(connection){ connection.sendText(str) }) } Client: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;WebSocket&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Chat Room&lt;/h1&gt; &lt;input id=&quot;sendTxt&quot; type=&quot;text&quot; /&gt; &lt;button id=&quot;sendBtn&quot;&gt;发送&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var websocket = new WebSocket(&quot;ws://localhost:8001/&quot;); function showMessage(str) { var div = document.createElement(&#39;div&#39;); div.innerHTML = str; document.body.appendChild(div); } websocket.onopen = function() { console.log(&quot;websocket open&quot;); document.getElementById(&quot;sendBtn&quot;).onclick = function(){ var txt = document.getElementById(&quot;sendTxt&quot;).value; if(txt) { websocket.send(txt); } } } websocket.onclose = function() { console.log(&quot;websocket close&quot;); } websocket.onmessage = function(e) { console.log(e.data); showMessage(e.data); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>计算机网络相关</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>计算机网络</tag>
        <tag>Socket编程</tag>
        <tag>聊天室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2Fposts%2Fd4a1185%2F</url>
    <content type="text"><![CDATA[把博客从简书搬到Hexo啦~辣鸡简书的打包方式，把文章的名当做文件名存了，转hexo后导致文章的url出现中文！简直不能忍，但是嫌麻烦懒得改了，就以后所有文章文件名都存中文吧 print Hello World !]]></content>
      <categories>
        <category>不知道怎么归类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git的ssh key创建]]></title>
    <url>%2Fposts%2F7c2130d4%2F</url>
    <content type="text"><![CDATA[Git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。如果未配置ssh key将无法clone远程代码仓库到本地。 第一步.创建user.name和email git config --global user.name &quot;EwdAger&quot; git config --global user.email &quot;ewdager@hotmail.com&quot; 第二步.生成SSH密钥： 查看是否已经有了ssh密钥：cd ~/.ssh,Windows用户的路径在C:\Users\EwdAger\.ssh下如果是刚安装git则不会有此文件夹，有则备份删除 生成ssh keysudo ssh-keygen -t rsa -C &quot;ewdager@hotmail.com&quot;然后按三下回车最后得到了两个文件：id_rsa和id_rsa.pub 在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥用编辑器打开id_rsa.pub复制全部内容到github的settings的SSH and GPG keys设置中，title取个好记的名字就行。 然后就能使用clone了]]></content>
      <categories>
        <category>不知道怎么归类</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django模型的Field Types总结]]></title>
    <url>%2Fposts%2F62657fb0%2F</url>
    <content type="text"><![CDATA[Field Types 常用参数： null 如果设置为 True , Django 存放一个 NULL 到数据库字段。默认为 False。 blank 如果设置为 True , 此 field 允许为 blank （空白），默认为 False。 choices 一个2元元组的元组或者列表，如果执行 choices ， Django 的 admin 就会使用 选择框而不是标准的 text 框填写这个 field。 YEAR_IN_SCHOOL_CHOICES = ( (u&#39;FR&#39;, u&#39;Freshman&#39;), (u&#39;SO&#39;, u&#39;Sophomore&#39;), (u&#39;JR&#39;, u&#39;Junior&#39;), (u&#39;SR&#39;, u&#39;Senior&#39;), (u&#39;GR&#39;, u&#39;Graduate&#39;), ) 2元元组的第一个元素是要存入 database 的数据，第二个元素是 admin 的界面 显示的数据。使用了 choices 参数的 field 在其 model 示例里，可以用 “get_field的名 字_display” 方法 显示 choices 的显示字串（就是2元元组的第二个数据）。示 例： from django.db import models class Person(models.Model): GENDER_CHOICES = ( (u&#39;M&#39;, u&#39;Male&#39;), (u&#39;F&#39;, u&#39;Female&#39;), ) name = models.CharField(max_length=60) gender = models.CharField(max_length=2, choices=GENDER_CHOICES) &gt;&gt;&gt; p = Person(name=&quot;Fred Flinstone&quot;, gender=&quot;M&quot;) &gt;&gt;&gt; p.save() &gt;&gt;&gt; p.gender u&#39;M&#39; &gt;&gt;&gt; p.get_gender_display() u&#39;Male&#39; default field 的默认值，可以使用可调用对象（a callable object），如果使用可调用 对象，那么每次创建此 model 的新对象时调用可调用对象。常见如 datatime 。 help_text help_text 的值可以在 admin form 里显示，不过即使不使用 admin ，也可以当 做描述文档使用。 primary_key 如果为 True ， 这个 field 就是此 model 的 primary key 。 unique 如果为 True， 此 field 在这个 table 里必须唯一。 verbose_name verbose，详细的意思。verbose_name，就可以理解为详细的名字吧。除了ForeignKey, ManyToManyField 和 OneToOneField之外，每个类型的字段都有一个可选的第一位置参数－详细的名字。如果没有给出详细的名称，Django将自动使用字段的属性名来代替他。替代过程中会转换下划线为空格。该字段中，名字的详情为”person’s first name”：first_name = models.CharField(“person’s first name”, max_length=30) 以下字段中，first_name的详细名字为”first name”:first_name = models.CharField(max_length=30) ForeignKey, ManyToManyField 和 OneToOneField要求第一个参数是模型的类，所以需要使用verbose_name关键字参数，如：poll = models.ForeignKey(Poll, verbose_name=”the related poll”)sites = models.ManyToManyField(Site, verbose_name=”list of sites”)place = models.OneToOneField(Place, verbose_name=”related place”) 在需要的时候Django会自动大写 verbose_name的首字母。原来verbose_name字段就是为ForeignKey, ManyToManyField 和 OneToOneField这三种关系准备的啊！ 常见Filed Types 1、AutoField 如果没有指明主键，就会产生一个自增的主键。 2、BigIntegerField 64位的整型数值，从 -2^63 (-9223372036854775808) 到 2^63-1(9223372036854775807)。 3、BinaryField 存储原始二进制数据，仅支持字节分配。功能有限。 4、BooleanField 布尔型和NullBooleanField有区别，true/false，本类型不允许出现null。 5、CharField 字符串，一般都在创建时写入max_length参数。 6、CommaSeparatedIntegerField 逗号分隔的整数，考虑到数据库的移植性，max_length参数应该必选。原文解释：A field of integers separated by commas. As in CharField, the max_length argument is required and the note about database portability mentioned there should be heeded. 7、DateField 时间，对应Python的datetime.date，额外的参数：DateField.auto_now表示是否每次修改时改变时间，DateField.auto_now_add 表示是否创建时表示时间，一般来说数据库重要的表都要有这样的字段记录创建字段时间个最后一次改变的时间。关于时间的话，建议timestamp，当然 python的话还是DateTime吧。 8、DateTimeField 对应Python的datetime.datetime，参照参数（7）。 9、DecimalField 固定精度的十进制数，一般用来存金额相关的数据。对应python的Decimal，额外的参数包括DecimalField.max_digits和DecimalField.decimal_places ，这个还是要参照一下mysql的Decimal类型，http://database.51cto.com/art/201005/201651.htm例如：price = models.DecimalField(max_digits=8,decimal_places=2) 10、EmailField 字符串，会检查是否是合法的email地址 11、FileField class FileField([upload_to=None, max_length=100, options])存文件的，参数upload_to在1.7之前的一些老版本中必选的 12、FloatField 浮点数，必填参数：max_digits，数字长度；decimal_places，有效位数。 13、ImageField class ImageField([upload_to=None, height_field=None, width_field=None, max_length=100, options])图片文件类型，继承了FileField的所有属性和方法。参数除upload_to外，还有height_field，width_field等属性。 14、IntegerField [-2147483648,2147483647 ]的取值范围对Django所支持的数据库都是安全的。 15、IPAddressField 点分十进制表示的IP地址，如10.0.0.1 16、GenericIPAddressField ip v4和ip v6地址表示，ipv6遵循RFC 4291section 2.2,17、NullBooleanField可以包含空值的布尔类型，相当于设置了null=True的BooleanField。18、PositiveIntegerField正整数或0类型，取值范围为[0 ,2147483647]19、PositiveSmallIntegerField正短整数或0类型，类似于PositiveIntegerField，取值范围依赖于数据库特性，[0 ,32767]的取值范围对Django所支持的数据库都是安全的。20、SlugField只能包含字母，数字，下划线和连字符的字符串，通常被用于URLs表示。可选参数max_length=50，prepopulate_from用于指示在admin表单中的可选值。db_index，默认为True。21、SmallIntegerField小整数字段，类似于IntegerField，取值范围依赖于数据库特性，[-32768 ,32767]的取值范围对Django所支持的数据库都是安全的。22、TextField文本类型23、TimeField时间，对应Python的datetime.time24、URLField存储URL的字符串，默认长度200；verify_exists(True)，检查URL可用性。25、FilePathField class FilePathField(path=None[, match=None, recursive=False, max_length=100, **options])类似于CharField，但是取值被限制为指定路径内的文件名，path参数是必选的。]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Web框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验六]]></title>
    <url>%2Fposts%2Fcfee3b66%2F</url>
    <content type="text"><![CDATA[实验内容本实验通过编程模拟实现几种常见的磁盘调度算法 简直可怕，怎么可能写出来磁盘调度算法啊喂！算法实现倒还好说，就是一个排序算法。但是！访问的柱面就是随机生成的所以还要写iterator？！这里简单描述一下各种磁盘调度算法。 例:假定某磁盘共有200个柱面，编号为0-199，如果在为访问143号柱面的请求者服务后，当前正在为访问125号柱面的请求服务，同时有若干请求者在等待服务，它们每次要访问的柱面号为 86，147，91，177，94，150，102，175，130 1、先来先服务算法（FCFS）First Come First Service这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。先来先服务 （125）86.147.91.177.94.150.102.175.130 2、最短寻道时间优先算法（SSTF） Shortest Seek Time First该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。最短寻道时间优先（125）130.147.150.175.177.102.94.91.86 3、扫描算法（SCAN）电梯调度扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。电梯调度（125）102.94.91.86.130.147.150.175.177 4、循环扫描算法（CSCAN）循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。循环扫描 （125）130.147.150.175.177.86.91.94.102 转自枫叶 以下是抄的代码#include &lt;iostream&gt; #include &lt;time.h&gt; #include &lt;vector&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;windows.h&gt; #include &lt;fstream&gt; using namespace std; int position = 0; //当前磁道位置 int dis = 0; double average_distance = 0; void request(vector&lt;int&gt;&amp;m_vec,ofstream &amp;outfile){ cout&lt;&lt;&quot;随机生成磁盘序列：&quot;&lt;&lt;endl; int n = 0; srand(time(NULL)); //添加随机数种子 n = rand() % 20 + 1; int temp = 0; for(int i=0;i&lt;n;i++){ temp = rand() % 100; m_vec.push_back(temp); cout&lt;&lt;temp&lt;&lt;&quot; &quot;; outfile&lt;&lt;temp&lt;&lt;endl; } cout&lt;&lt;endl; position = rand() % 100; cout&lt;&lt;&quot;当前磁道：&quot;&lt;&lt;position&lt;&lt;endl; } void compute_dis(vector&lt;int&gt;m_vec,int &amp;dis,double &amp;average_distance){ average_distance = (double)dis / (double)m_vec.size(); } void FIFO(vector&lt;int&gt;m_vec,int position){ //先来先服务算法 dis = 0; average_distance = 0; for(vector&lt;int&gt;::iterator it=m_vec.begin();it!=m_vec.end();it++){ dis += abs(position-*it); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;*it; position = *it; } compute_dis(m_vec,dis,average_distance); } void SSTF(vector&lt;int&gt;m_vec,int position){ //最短寻道时间算法 dis = 0; average_distance = 0; sort(m_vec.begin(),m_vec.end()); //从小到大排序 int i = 0; for(vector&lt;int&gt;::iterator it=m_vec.begin();it!=m_vec.end();it++){ if(position &gt;= *it) i++; } int count = 0; int left = i-1; int right = i; while(count&lt;m_vec.size()){ if((left &gt;=0 &amp;&amp; abs(m_vec[right]-position) &gt; abs(m_vec[left]-position)) || right&gt;=m_vec.size()){ dis += abs(m_vec[left]-position); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[left]; position = m_vec[left]; left--; } else{ dis += abs(m_vec[right]-position); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[right]; position = m_vec[right]; right++; } count++; } compute_dis(m_vec,dis,average_distance); } void SCAN(vector&lt;int&gt;m_vec,int position){ //电梯调度算法 dis = 0; average_distance = 0; sort(m_vec.begin(),m_vec.end()); //从小到大排序 int i = 0; for(vector&lt;int&gt;::iterator it=m_vec.begin();it!=m_vec.end();it++){ if(position &gt;= *it) i++; //找到position所在的磁道 } int left = i - 1; //先从外到内扫描 int right = i; while(left &gt;= 0){ dis += abs(position - m_vec[left]); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[left]; position = m_vec[left]; left --; } while(right &lt; m_vec.size()){ dis += abs(position - m_vec[right]); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[right]; position = m_vec[right]; right ++; } compute_dis(m_vec,dis,average_distance); } void CSCAN(vector&lt;int&gt;m_vec,int position){ //循环扫描算法 dis = 0; average_distance = 0; sort(m_vec.begin(),m_vec.end()); //从小到大排序 int i = 0; for(vector&lt;int&gt;::iterator it=m_vec.begin();it!=m_vec.end();it++){ if(position &gt;= *it) i++; //找到position所在的磁道 } int left = i - 1; //先从外到内扫描 int right = i; while(left &gt;= 0){ dis += abs(position - m_vec[left]); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[left]; position = m_vec[left]; left --; } position = 100; //立即到最外侧的磁道 int len = m_vec.size()-1; while(len &gt;= right){ dis += abs(position - m_vec[len]); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[len]; position = m_vec[len]; len --; } compute_dis(m_vec,dis,average_distance); } void FSCAN(vector&lt;int&gt;m_vec,int position){ //分步电梯调度算法，。分两个队列 dis = 0; average_distance = 0; //SCAN(m_vec,position); sort(m_vec.begin(),m_vec.end()); //从小到大排序 int i = 0; for(vector&lt;int&gt;::iterator it=m_vec.begin();it!=m_vec.end();it++){ if(position &gt;= *it) i++; //找到position所在的磁道 } int left = i - 1; //先从外到内扫描 int right = i; while(left &gt;= 0){ dis += abs(position - m_vec[left]); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[left]; position = m_vec[left]; left --; } while(right &lt; m_vec.size()){ dis += abs(position - m_vec[right]); Sleep(500); cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;m_vec[right]; position = m_vec[right]; right ++; } cout&lt;&lt;endl; cout&lt;&lt;&quot;在扫描的过程中新产生的服务序列：&quot;&lt;&lt;endl; vector&lt;int&gt;ve; while(!ve.empty()) ve.pop_back(); int n = 0; n = rand() % 20 + 1; int temp = 0; for(i=0;i&lt;n;i++){ temp = rand() % 100; cout&lt;&lt;temp&lt;&lt;&quot; &quot;; ve.push_back(temp); } cout&lt;&lt;endl; cout&lt;&lt;position; SCAN(ve,position); average_distance = (double)dis / (double)(m_vec.size()+ve.size()); } void print(){ cout&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;&quot;经计算，磁头移动的总距离为:&quot;&lt;&lt;dis&lt;&lt;endl; cout&lt;&lt;&quot;磁头平均移动距离:&quot;&lt;&lt;average_distance&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;endl; } int choose_algorithm(vector&lt;int&gt;m_vec){ cout&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;&quot;本实验可用的调度算法有以下5种：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1.FIFO 2.SSTF 3.SCAN 4.CSCAN 5.FSCAN 6.结束本序列的调度 7.结束程序&quot;&lt;&lt;endl; int choice = 0; cout&lt;&lt;&quot;选择：&quot;&lt;&lt;endl; cin&gt;&gt;choice; cout&lt;&lt;endl; while(choice!=6 &amp;&amp; choice!=7){ cout&lt;&lt;&quot;磁盘请求的服务状况：&quot;&lt;&lt;endl; cout&lt;&lt;position; switch(choice){ case 1: FIFO(m_vec,position);break; case 2: SSTF(m_vec,position);break; case 3: SCAN(m_vec,position);break; case 4: CSCAN(m_vec,position);break; case 5: FSCAN(m_vec,position);break; default: cout&lt;&lt;&quot;******非法输入！******&quot;&lt;&lt;endl&lt;&lt;endl;break; } if(choice&lt;=7 &amp;&amp; choice&gt;=1) print(); cout&lt;&lt;&quot;选择：&quot;&lt;&lt;endl; cin&gt;&gt;choice; } if(choice == 7) return 0; else cout&lt;&lt;endl&lt;&lt;endl; return 1; } int main(){ cout&lt;&lt;&quot;---------------磁盘调度算法模拟实验-----------------&quot;&lt;&lt;endl; ofstream outfile; outfile.open(&quot;data.txt&quot;); while(1){ vector&lt;int&gt; vec; while(!vec.empty()) vec.pop_back(); request(vec,outfile); //请求服务序列 int flag = choose_algorithm(vec); if(flag == 0) break; } outfile.close(); return 0; }]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验五]]></title>
    <url>%2Fposts%2Fc9f7f365%2F</url>
    <content type="text"><![CDATA[步骤一- 什么是分页过程当 Windows 求助于硬盘以获得虚拟内存时，这个过程被称为分页 (paging) 。具体是通过MMU（Memory Management Unit 内存管理单元）将硬盘上的虚拟地址映射为物理内存地址。优点是使大内存占用程序不至于异常退出。缺点是虚拟内存要远慢于物理内存（访问虚拟内存大约要4-10毫秒，访问物理内存只要60 us）- 什么是内存共享共享内存是被多个进程共享的一部分物理内存。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。- 什么是“未分页合并内存”和“分页合并内存”Windows规定有些虚拟内存可以交换到文件中，这类内存被称为分页内存，有些虚拟内存永远不会交换到文件中，这些内存叫非分页内存。比如用于处理页故障的代码和数据结构必须常驻内存，这些就是未分页内存。- Windows xp 中未分页合并内存的最大限制是多少256MB- Windows xp 分页文件默认设置的最小容量和最大容量是多少Windows xp 使用内存数量的 1.5 倍作为分页文件的最小容量，这个最小容量的两倍作为最大容量。（这里似乎有个问题，但还是按指导书上来了。虚拟内存应该最大可设置为盘符最大可用空间） 步骤三 映像名称 PID CPU CPU时间 内存使用 chrome 1088 00 0:00:02 45.492K //这里的chrome有很多进程，因为涉及浏览器内核问题（每个标签、插件一个进程）只取pid为1088的讨论。 步骤六- 计算分页文件的大小 所选驱动器 (C: ) 的页面文件大小：驱动器： C 可用空间：15889 MB初始大小 (MB) ：0最大值 (MB) ：0//此驱动器无分页文件 所有驱动器的页面文件大小：允许的最小值：16 MB 推荐：12081 MB当前已分配：8192 MB 虚拟内存每页容量为：4KB 最小应用地址：0x000100000最大应用地址：0x7ffeffff当前可供应用程序使用的内存空间为：20662MB当前计算机的实际内存大小为：8055MB理论上每个 Windows 应用程序可以独占的最大存储空间是：20662MB 将系统当前的自由区 (free) 虚拟地址空间 地址 大小 虚拟地址空间类型 访问权限 描述 000134000-00140000 48KB free NOACCESS NO 00141000-00150000 60KB free NOACCESS NO 00151000-00160000 60KB free NOACCESS NO 将系统当前的已调配区 (committed) 虚拟地址空间 地址 大小 虚拟地址空间类型 访问权限 描述 00010000-00020000 64KB committed READWRIT 具有READWRITE权限的已调配映射内存区 00020000-00030000 64KB committed READWRITE 具有READWRITE权限的已调配映射内存区 0012d000-0012e000 4KB committed GUARD,READWRITE 具有GUARD权限的已调配私有内存区 …… …… …… …… …… 将系统当前的保留区 (reserved) 虚拟地址空间 地址 大小 虚拟地址空间类型 访问权限 描述 00030000-0012d000 0.98MB reserverd READONLY 具有READONLY权限的已调配私有内存区 0018c000-00260000 848KB reserved READONLY 具有READONLY权限的已调配私有内存区 002d8000-00390000 736KB reserved READONLY 具有READONLY权限的已调配私有内存区 …… …… …… …… ……]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)解决强智教务系统非IE下无法创建对象错误]]></title>
    <url>%2Fposts%2Fd496c7e0%2F</url>
    <content type="text"><![CDATA[最近要弄教务网的模拟登陆，但苦于教务网只兼容IE8以下的浏览器，不能用chrome强大的F12抓包就很烦，然后发现Fly俊大佬弄了一个相当强的插件啊。但是怕Fly俊大佬的博客失效，所以私自留了个档。侵删啊大佬~ 以下内容均为转载 学校教务系统由于长期缺乏必要的维护，目前依旧只兼容IE8及以下浏览器。使用非IE浏览器访问登陆界面是没有问题，但是登录进去后就会报错，并且所有功能都无法使用。这对于使用非IE浏览器的用户简直就是噩梦，特别对于非Windows用户，以下是简单的解决办法 学长的修复 一位高能的学长在无法忍受这个问题后，进行了部分修复每次使用非IE浏览器访问后，替换一个JS文件为学长修改后的文件就可以正常使用了但是这个学长修复的结果又产生了一些新问题无法创建对象问题解决了，但是又产生了新问题，所有的内容都重复了两遍替换JS文件对小白用户来说是个难点 新的解决办法 经过查找、调试，终于是找到了内容重复的原因，内容是不再重复了然而怎么让普通用户也能替换JS文件呢感觉最好的办法还是写个浏览器插件，自动替换JS，不过需要注意以下几个问题。插件只针对Chrome浏览器编写，不过360浏览器等使用Chrome内核的浏览器可能能够使用，不过未测试。 由于教务网浏览器兼容问题众多，所以此插件并不能完美修复所有问题。 插件使用教程 插件原地址&gt;&gt; 度盘密码udn8&gt;&gt; 在谷歌浏览器中打开 chrome://extensions/ 将下载好的插件拖放至上一步骤打开的 插件管理页面，然后会弹出如下窗口，点击添加即可 然后就可以开开心心的打开教务网了]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>教务网</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验四代码]]></title>
    <url>%2Fposts%2F9a468f74%2F</url>
    <content type="text"><![CDATA[直接上代码 #include &lt;iostream&gt; const int MAXM = 1; const int MAXN = 100; using namespace std; int Resource[MAXM], Available[MAXM]; int Claim[MAXN][MAXM], Allocation[MAXN][MAXM]; int n; int Need[MAXN][MAXM]; bool Finish[MAXN]; int finished; bool IsAvailable(const int thisNeed[], const int thisAvailable[]){ for(int i = 0; i &lt; MAXM; i++){ if(thisNeed[i] &gt; thisAvailable[i]) return false; } return true; } void LineAdd(int LineA[], int LineB[]){ for(int i = 0; i &lt; MAXM; i++){ LineA[i] += LineB[i]; } } int main() { cout &lt;&lt; &quot;Please input &quot; &lt;&lt; MAXM &lt;&lt; &quot; integers of Resource:&quot; &lt;&lt; endl; for(int i = 0; i &lt; MAXM; i++) cin &gt;&gt; Resource[i]; cout &lt;&lt; &quot;Please input &quot; &lt;&lt; MAXM &lt;&lt; &quot; integers of Available:&quot; &lt;&lt; endl; for(int i = 0; i &lt; MAXM; i++) cin &gt;&gt; Available[i]; cout &lt;&lt; &quot;Please input the number of process:&quot; &lt;&lt; endl; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cout &lt;&lt; &quot;Please input &quot; &lt;&lt; MAXM &lt;&lt; &quot; integers of Claim[&quot; &lt;&lt; i &lt;&lt; &quot;]:&quot; &lt;&lt; endl; for(int j = 0; j &lt; MAXM; j++) cin &gt;&gt; Claim[i][j]; } for(int i = 1; i &lt;= n; i++){ cout &lt;&lt; &quot;Please input &quot; &lt;&lt; MAXM &lt;&lt; &quot; integers of Allocation[&quot; &lt;&lt; i &lt;&lt; &quot;]:&quot; &lt;&lt; endl; for(int j = 0; j &lt; MAXM; j++) cin &gt;&gt; Allocation[i][j]; } cout &lt;&lt; &quot;Running...&quot; &lt;&lt; endl; for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt; MAXM; j++){ Need[i][j] = Claim[i][j] - Allocation[i][j]; } Finish[i] = false; } finished = 0; for(int times = 0; times &lt; n; times++){ for(int i = 1; i &lt;= n; i++){ if(!Finish[i]){ if(IsAvailable(Need[i], Available)){ Finish[i] = true; finished++; LineAdd(Available, Claim[i]); } } } } if(finished == n){ cout &lt;&lt; &quot;True&quot; &lt;&lt; endl; }else{ cout &lt;&lt; &quot;False&quot; &lt;&lt; endl; } return 0; }]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验三程序分析]]></title>
    <url>%2Fposts%2Fb2a42beb%2F</url>
    <content type="text"><![CDATA[直接上代码~ #include &lt;windows.h&gt; #include &lt;iostream&gt; const unsigned short SIZE_OF_BUFFER = 2; //缓冲区长度 unsigned short ProductID = 0; //产品号 unsigned short ConsumeID = 0; //将被消耗的产品号 unsigned short in = 0; //产品进缓冲区时的缓冲区下标 unsigned short out = 0; //产品出缓冲区时的缓冲区下标 int buffer[SIZE_OF_BUFFER]; //缓冲区是个循环队列 bool p_ccontinue = true; //控制程序结束 HANDLE Mutex; //用于线程间的互斥 HANDLE FullSemaphore; //当缓冲区满时迫使生产者等待 HANDLE EmptySemaphore; //当缓冲区空时迫使消费者等待 DWORD WINAPI Producer(LPVOID); //生产者线程 DWORD WINAPI Consumer(LPVOID); //消费者线程 int main() { //创建各个互斥信号 //注意，互斥信号量和同步信号量的定义方法不同，互斥信号量调用的是 CreateMutex 函数， //同步信号量调用的是 CreateSemaphore 函数，函数的返回值都是句柄。 Mutex = CreateMutex(NULL,FALSE,NULL); EmptySemaphore = CreateSemaphore(NULL,SIZE_OF_BUFFER,SIZE_OF_BUFFER,NULL); //将上句做如下修改，看看结果会怎样 //EmptySemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER-1,NULL); FullSemaphore = CreateSemaphore(NULL,0,SIZE_OF_BUFFER,NULL); //调整下面的数值，可以发现，当生产者个数多于消费者个数时， //生产速度快，生产者经常等待消费者；反之，消费者经常等待 const unsigned short PRODUCERS_COUNT = 3; //生产者的个数 const unsigned short CONSUMERS_COUNT = 1; //消费者的个数 //总的线程数 const unsigned short THREADS_COUNT = PRODUCERS_COUNT+CONSUMERS_COUNT; HANDLE hThreads[THREADS_COUNT]; //各线程的 handle DWORD producerID[PRODUCERS_COUNT]; //生产者线程的标识符 DWORD consumerID[CONSUMERS_COUNT]; //消费者线程的标识符 //创建生产者线程 for (int i=0; i&lt;PRODUCERS_COUNT; ++i) { hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]); if (hThreads[i]==NULL) return -1; } //创建消费者线程 for (int i=0; i&lt;CONSUMERS_COUNT; ++i) { hThreads[PRODUCERS_COUNT+i]=CreateThread(NULL,0,Consumer,NULL,0,&amp;consumerID[i]); if (hThreads[i]==NULL) return -1; } while(p_ccontinue) { if(getchar()) { //按回车后终止程序运行 p_ccontinue = false; } } return 0; } //生产一个产品。简单模拟了一下，仅输出新产品的 ID 号 void Produce() { std::cout &lt;&lt; std::endl&lt;&lt; &quot;Producing &quot; &lt;&lt; ++ProductID &lt;&lt; &quot; ... &quot;; std::cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl; } //把新生产的产品放入缓冲区 void Append() { std::cerr &lt;&lt; &quot;Appending a product ... &quot;; buffer[in] = ProductID; in = (in+1)%SIZE_OF_BUFFER; std::cerr &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl; //输出缓冲区当前的状态 for (int i=0; i&lt;SIZE_OF_BUFFER; ++i) { std::cout &lt;&lt; i &lt;&lt;&quot;: &quot; &lt;&lt; buffer[i]; if (i==in) std::cout &lt;&lt; &quot; &lt;-- 生产&quot;; if (i==out) std::cout &lt;&lt; &quot; &lt;-- 消费&quot;; std::cout &lt;&lt; std::endl; } } //从缓冲区中取出一个产品 void Take() { std::cerr &lt;&lt; &quot;Taking a product ... &quot;; ConsumeID = buffer[out]; buffer[out] = 0; out = (out+1)%SIZE_OF_BUFFER; std::cerr &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl; //输出缓冲区当前的状态 for (int i=0; i&lt;SIZE_OF_BUFFER; ++i) { std::cout &lt;&lt; i &lt;&lt;&quot;: &quot; &lt;&lt; buffer[i]; if (i==in) std::cout &lt;&lt; &quot; &lt;-- 生产&quot;; if (i==out) std::cout &lt;&lt; &quot; &lt;-- 消费&quot;; std::cout &lt;&lt; std::endl; } } //消耗一个产品 void Consume() { std::cout &lt;&lt; &quot;Consuming &quot; &lt;&lt; ConsumeID &lt;&lt; &quot; ... &quot;; std::cout &lt;&lt; &quot;Succeed&quot; &lt;&lt; std::endl; } //生产者 DWORD WINAPI Producer(LPVOID lpPara) { while(p_ccontinue) { WaitForSingleObject(EmptySemaphore,INFINITE); //p(empty); WaitForSingleObject(Mutex,INFINITE); //p(mutex); Produce(); Append(); Sleep(1500); ReleaseMutex(Mutex); //V(mutex); ReleaseSemaphore(FullSemaphore,1,NULL); //V(full); } return 0; } //消费者 DWORD WINAPI Consumer(LPVOID lpPara) { while(p_ccontinue) { WaitForSingleObject(FullSemaphore,INFINITE); //P(full); WaitForSingleObject(Mutex,INFINITE); //P(mutex); Take(); Consume(); Sleep(1500); ReleaseMutex(Mutex); //V(mutex); ReleaseSemaphore(EmptySemaphore,1,NULL); //V(empty); } return 0; } 运行结果&amp;结论： 从运行结果中能看到，生产的速度大于消费，生产者就要经常等待；生产速度小于消费，消费者就需要经常等待。步骤3中，线程的第一个执行函数是Producer,位于第三个参数。hThreads[i]=CreateThread(NULL,0,Producer,NULL,0,&amp;producerID[i]); 步骤5 修改EmptySemaphore的初始化方法后结果： 步骤6 1. CreateMutex 中有几个参数，各代表什么含义。 根据MSDN中函数解析，可以得出CreateMutex中的参数分别代表 LPSECURITY_ATTRIBUTES lpMutexAttributes //代表安全属性指针 BOOL bInitialOwner //代表布尔bInitialOwner LPCTSTR lpName //代表LPCTSTR类型lpName 2. CreateSemaphore 中有几个参数，各代表什么含义，信号量的初值在第几个参数中。 四个参数：1.安全性2.设置信号量的初始计数3.设置信号量的最大计数4.指定信号量对象的名称 3. 程序中 P、V 原语所对应的实际 Windows API 函数是什么，写出这几条语句。 P:Take() V:Append() 4. CreateMutex 能用 CreateSemaphore 替代吗？尝试修改程序 3-1，将信号量 Mutex 完全用CreateSemaphore 及相关函数实现。写出要修改的语句。 CreateMutex能用CreateSemaphore代替，Mutex = CreateSemaphore(NULL, false, false, NULL);]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux环境下使用mono运行asf挂卡]]></title>
    <url>%2Fposts%2F5e6f73c9%2F</url>
    <content type="text"><![CDATA[杰瑞包大好评啊，但是带来的后果就是挂卡挂不完了。然而手里的服务器全是linux环境的并不支持C#写的ASF，所以用mono f**k之。 Ubuntu篇接下来介绍如何安装mono，以Ubuntu 14.04为例。 1. 运行下面代码授权注册repo源并更新软件列表： $ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF $ echo &quot;deb http://download.mono-project.com/repo/debian wheezy main&quot; | sudo tee /etc/apt/sources.list.d/mono-xamarin.list $ sudo apt-get update 2. 安装mono $ sudo apt-get install mono-complete 3. 测试mono是否安装成功 mono -V //如果没有提示错误就可以啦 3. 运行asf首先通过ftp工具将配置好的asf传到服务器上。然后新建一个窗口screen -S ASF，最后进入asf的目录再运行asf就行啦~ cd /opt/ASF mono ASF.exe CentOS篇这里转一个教程，当做留档了。1. 添加yum源 rpm --import &quot;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF&quot; yum-config-manager --add-repo http://download.mono-project.com/repo/centos/ 2. 有可能提示找不到yum-config-manager,这个是因为系统默认没有安装这个命令,这个命令在yum-utils 包里,可以通过命令yum -y install yum-utils安装。 3. 安装mono yum -y install mono-complete 4. 以下参照上面的3步以后 PS：关于“最小化Screen”，因为开启了screen后就不能进行其他操作了，我们的服务器当然不只是为了挂卡而存在的，所以可以通过按住Ctrl+A+D“最小化”screen窗口。 PPS：还有就是恢复的话，在终端里输入screen -r ASF就可以了 PPPS：如果不想挂卡了，就输入以下命令杀掉进程。 screen -ls #显示所有的screen窗口名字和进程号 kill [进程号] 附上成功图：]]></content>
      <categories>
        <category>Steam骚操作</category>
      </categories>
      <tags>
        <tag>Steam</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验二归纳]]></title>
    <url>%2Fposts%2F6ee94925%2F</url>
    <content type="text"><![CDATA[本实验是要求在linux环境下测试fork()和exec()，并建立一个简单的shell（带cd、env、echo、help、jobs、quit命令） fork() 这一节没啥难度，主要是测试当前linux环境下gcc是否能编译成功 清单 2-1 创建进程 #include &lt;stdio.h&gt; //此处指导书上没有 int main (){ int x; while((x=fork())==-1); if (x==0) printf(&quot;a&quot;); else printf(&quot;b&quot;); printf(&quot;c&quot;); } 这里出现了很奇妙的问题，指导书上没有使用stdio头文件，不过显然这样编译不会通过。但是加上了以后又出现了一个坑，实验室里的linux没有安装gcc的包依赖。此处需要我们重装个gcc $ sudo apt-get install build-essential //此处也许会失败，提示缺少几个依赖，那就安装相应的包 $ sudo apt-get install g++ //上一步如果不行就运行这个再运行上一条 linux下怎么build .c文件也留档一下吧$ gcc -o hello hello.c // 第一个为生成的文件名，第二个为.c文件 exec() 这真是一个骚操作。可以直接用新的进程映象置换当前的进程映象，留档函数原型 exec 系列有 6 个函数，原型如下：extern char *environ;int execl( const char path, const char arg, …);int execlp( const char file, const char arg, …);int execle( const char path, const char arg , …, char const envp[]);int execv( const char path, char const argv[]);int execve (const char filename, char const argv [], char const envp[]);int execvp( const char file, char const argv[]);exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重置为缺省行为。在函数 execl,execlp,和 execle 中, const char arg 以及省略号代表的参数可被视为 arg0,arg1, …,argn。它们合起来描述了指向 NULL 结尾的字符串的指针列表，即执行程序的参数列表。作为约定,第一个 arg 参数应该指向执行程序名自身,参数列表必须用 NULL 指针结束。execv 和 execvp 函数提供指向 NULL 结尾的字符串的指针数组作为新程序的参数列表。作为约定，指针数组中第一个元素应该指向执行程序名自身。指针数组必须用 NULL 指针结束。execle 函数同时说明了执行进程的环境(environment),它在 NULL 指针后面要求一个附加参数,NULL 指针用于结束参数列表,或者说,argv 数组。这个附加参数是指向 NULL 结尾的字符串的指针数组,它必须用 NULL 指针结束。其它函数从当前进程的 environ 外部变量中获取新进程的环境。execlp和execvp可根据path搜索合适的程序运行，其它则需要给出程序全路径。execve（）类似 execv（），但是加上了环境的处理。 在把此处的示例程序解释一下吧： #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int main(){ pid_t pid; /* fork a child process */ pid = fork(); if (pid &lt; 0){ /* error occurred */ fprintf(stderr, &quot;Fork Failed&quot;); return 1; } else if (pid == 0){ /* 子进程 */ execlp(&quot;/bin/ls&quot;,&quot;ls&quot;,NULL); } else { /* 父进程 */ / * 父进程将一直等待，直到子进程运行完毕*/ wait(NULL); printf(&quot;Child Complete&quot;); } return 0; } 我的理解是这份代码的意思应该是，创建一个进程，如果该进程的pid&lt;0（当然创建fork成功会返回大于0的数）提示fork失败。然后再使用execlp调用系统中的ls命令，运行结果图 ##简单的shell #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; char op[256]; char arg[256]; char str[1024]; int main() { pid_t CurSon; while(1){ scanf(&quot;%s&quot;, op); if(strcmp(op, &quot;quit&quot;) == 0 || strcmp(op, &quot;exit&quot;) == 0 || strcmp(op, &quot;bye&quot;) == 0){ printf(&quot;\nQuiting...Bye~&quot;); return 0; }else if(strcmp(op, &quot;help&quot;) == 0){ printf(&quot;It&#39;s a fake shell~\n&quot;); }else if(strcmp(op, &quot;cd&quot;) == 0){ scanf(&quot;%s&quot;, arg); sprintf(str, &quot;cd %s&quot;, arg); system(str); }else if(strcmp(op, &quot;environ&quot;) == 0){ system(&quot;env&quot;); }else if(strcmp(op, &quot;echo&quot;) == 0){ scanf(&quot;%s&quot;, arg); sprintf(str, &quot;echo %s&quot;, arg); system(str); }else if(strcmp(op, &quot;jobs&quot;) == 0){ system(&quot;ps&quot;); }else{ fgets(arg, 256, stdin); sprintf(str, &quot;%s %s&quot;, op, arg); while((CurSon = fork()) &lt; 0); if(CurSon == 0){ system(str); return 0; }else{ wait(NULL); printf(&quot;%s\n&quot;, str); printf(&quot;Complete...\n&quot;); } } } return 0; }]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验一资料归纳]]></title>
    <url>%2Fposts%2Fa46183c6%2F</url>
    <content type="text"><![CDATA[句柄指导书上出现了一个陌生的名词“句柄（handle）”，感觉比较奇妙，因为在之前编写微信公众号小程序看教程也编写了一个handle程序。所以留档一下吧。 句柄（handle），有多种意义，其中第一种是指程序设计，第二种是指Windows编程。现在大部分都是指程序设计/程序开发这类。第一种解释：句柄是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄。第二种解释：整个Windows编程的基础。一个句柄是指使用的一个唯一的整数值，即一个4字节(64位程序中为8字节)长的数值，来标识应用程序中的不同对象和同类中的不同的实例，诸如，一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。应用程序能够通过句柄访问相应的对象的信息，但是句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。如果句柄不在I/O文件中，它是毫无用处的。 句柄是Windows用来标志应用程序中建立的或是使用的唯一整数，Windows大量使用了句柄来标识对象。 实验一中相关函数解释参考MSDN 中的帮助文件 CreateMutex() 、 OpenMutex() 、 ReleaseMutex() 和WaitForSingleObject()的使用方法，理解父子进程如何利用互斥体进行同步的。给出父子进程同步过程的一个大概描述。 CreateMutex()CreateMutex()函数可用来创建一个有名或无名的互斥量对象，其函数原型为HANDLE CreateMutex( LPSECURITY_ATTRIBUTESlpMutexAttributes, // 指向安全属性的指针 BOOLbInitialOwner, // 初始化互斥对象的所有者 LPCTSTRlpName // 指向互斥对象名的指针 ); OpenMutex()OpenMutex函数为现有的一个已命名互斥体对象创建一个新句柄,函数原型:HANDLE OpenMutex( DWORD dwDesiredAccess, // access BOOL bInheritHandle, // inheritance option LPCTSTR lpName // object name ); ReleaseMutex()ReleaseMutex是一种线性指令，具有释放线程拥有的互斥体的控制权,函数原型为： BOOL WINAPI ReleaseMutex( HANDLE hMutex //hMutex：HANDLE，制定一个互斥体的句柄。 ); WaitForSingleObject()当等待仍在挂起状态时，句柄被关闭，那么函数行为是未定义的。该句柄必须具有 SYNCHRONIZE 访问权限。函数原型： DWORD WINAPI WaitForSingleObject( __in HANDLE hHandle, __in DWORD dwMilliseconds ); 参数说明：hHandle[in]对象句柄。可以指定一系列的对象，如Event、Job、Memory resource notification、Mutex、Process、Semaphore、Thread、Waitable timer等。 dwMilliseconds[in]定时时间间隔，单位为milliseconds（毫秒）.如果指定一个非零值，函数处于等待状态直到hHandle标记的对象被触发，或者时间到了。如果dwMilliseconds为0，对象没有被触发信号，函数不会进入一个等待状态，它总是立即返回。如果dwMilliseconds为INFINITE，对象被触发信号后，函数才会返回。]]></content>
      <categories>
        <category>课程设计</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)计算机网络基础]]></title>
    <url>%2Fposts%2Ffdcebd2e%2F</url>
    <content type="text"><![CDATA[原文地址-程序员的自我修养（2）计算机网络几乎所有的计算机程序，都会牵涉到网络通信。因此，了解计算机基础网络知识，对每一个程序员来说都是异常重要的。 本文在介绍一些基础网络知识的同时，给出了一些高质量的系列文章链接，以方便大家随时参考学习。相信通过本文的学习，你能对计算机网络有全面的认识！ 在阅读本文之前，建议阅读以下两遍文章，以便对”计算机网络是如何工作”的有个大概的了解。互联网协议入门（一）互联网协议入门（二） 接下来，我们介绍一些基础网络知识。 OSI参考模型 一上来就是OSI七层参考模型，是不是有点晕？如果是，那先阅读文章开头推荐的那两篇文章吧！ 第7层：应用层(ApplicationLayer) 应用层能与应用程序界面沟通，以达到展示给用户的目的。在此常见的协议有:HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。 第6层：表示层(PresentationLayer) 表示层能为不同的客户端提供数据和信息的语法转换内码，使系统能解读成正确的数据。同时，也能提供压缩解压、加密解密。 第5层：会话层(SessionLayer) 会话层用于为通信双方制定通信方式，并创建、注销会话（双方通信）。 第4层：传输层(TransportLayer) 传输层用于控制数据流量，并且进行调试及错误处理，以确保通信顺利。而发送端的传输层会为分组加上序号，方便接收端把分组重组为有用的数据或文件。 第3层：网络层(NetworkLayer) 网络层的作用是决定如何将发送方的数据传到接收方。该层通过考虑网络拥塞程度、服务质量、发送优先权、每次路由的耗费来决定节点X到节点Y的最佳路径。我们熟知的路由器就工作在这一层，通过不断的接收与传送数据使得网络变得相互联通。 第2层：数据链路层(DatalinkLayer) 首先数据链路层的功能在于管理第一层的比特数据，并且将正确的数据发送到没有传输错误的路线中。创建还有辨认数据开始以及退出的位置同时予以标记。另外，就是处理由数据受损、丢失甚至重复传输错误的问题，使后续的层级不会受到影响，所以它运行数据的调试、重传或修正，还有决定设备何时进行传输。设备有：Bridge桥接器switch交换器 第1层：物理层(PhysicalLayer) 物理层定义了所有电子及物理设备的规范。其中特别定义了设备与物理媒介之间的关系，这包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器（在SAN中使用的主机适配器）以及其他的设备的设计定义。因为物理层传送的是原始的比特数据流，即设计的目的是为了保证当发送时的信号为二进制“1”时，对方接收到的也是二进制“1”而不是二进制“0”。因而就需要定义哪个设备有几个针脚，其中哪个针脚发送的多少电压代表二进制“1”或二进制“0”，还有例如一个bit需要持续几微秒，传输信号是否在双向上同时进行，最初的连接如何创建和最终如何终止等问题。 为了更好理解物理层与数据链路层之间的区别，可以把物理层认为是主要的，是与某个单一设备与传输媒介之间的交互有关，而数据链路层则更多地关注使用同一个通讯媒介的多个设备（例如，至少两个设备）之间的互动。物理层的作用是告诉某个设备如何传送信号至一个通讯媒介，以及另外一个设备如何接收这个信号（大多数情况下它并不会告诉设备如何与通讯媒介相连接）。有些过时的物理层标准如RS-232倒是的确使用物理线缆来控制通讯媒介的接入。 物理层的主要功能和提供的服务如下：在设备与传输媒介之间创建及终止连接。参与通讯过程使得资源可以在共享的多用户中有效分配。例如，冲突解决机制和流量控制。对信号进行调制或转换使得用户设备中的数字信号定义能与信道上实际传送的数字信号相匹配。这些信号可以经由物理线缆（例如铜缆和光缆）或是无线信道传送。 TCP/IP的5层模型 相比于OSI的七层模型，更常用的是TCP/IP的5层模型。TCP/IP的5层模型是将ISO的七层模型的应用层、表示层、会话层合并为应用层，得到如下图所示的五层模型： TCP/IP通信的三次握手、四次挥手 三次握手： 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 戏说TCP/IP状态转化图 TCP/IP协议是计算机网络中的一个协议族，也是网络编程中的重头戏！理解TCP/IP状态转化图，对理解TCP/IP协议的工作过程异常重要。 如下图所示，描述了一个状态机到另一个状态机的转变，已经触发这种状态转变的条件。 状态图详细说明如下： 1.CLOSED：起始点，在超时或者连接关闭时候进入此状态。 2.LISTEN：svr端在等待连接过来时候的状态，svr端为此要调用socket，bind,listen函数，就能进入此状态。此称为应用程序被动打开（等待客户端来连接）。 3.SYN_SENT:客户端发起连接，发送SYN给服务器端。如果服务器端不能连接，则直接进入CLOSED状态。 4.SYN_RCVD：跟3对应，服务器端接受客户端的SYN请求，服务器端由LISTEN状态进入SYN_RCVD状态。同时服务器端要回应一个ACK，同时发送一个SYN给客户端；另外一种情况，客户端在发起SYN的同时接收到服务器端得SYN请求，客户端就会由SYN_SENT到SYN_RCVD状态。 5.ESTABLISHED：服务器端和客户端在完成3次握手进入状态，说明已经可以开始传输数据了。 以上是建立连接时服务器端和客户端产生的状态转移说明。相对来说比较简单明了，如果你对三次握手比较熟悉，建立连接时的状态转移还是很容易理解。 下面，我们来看看连接关闭时候的状态转移说明，关闭需要进行4次双方的交互，还包括要处理一些善后工作（TIME_WAIT状态），注意，这里主动关闭的一方或被动关闭的一方不是指特指服务器端或者客户端，是相对于谁先发起关闭请求来说的： 6.FIN_WAIT_1:主动关闭的一方，由状态5进入此状态。具体的动作是发送FIN给对方。 7.FIN_WAIT_2:主动关闭的一方，接收到对方的FIN-ACK，进入此状态。由此不能再接收对方的数据。但是能够向对方发送数据。 8.CLOSE_WAIT：接收到FIN以后，被动关闭的一方进入此状态。具体动作是接收到FIN，同时发送ACK。 9.LAST_ACK：被动关闭的一方，发起关闭请求，由状态8进入此状态。具体动作是发送FIN给对方，同时在接收到ACK时进入CLOSED状态。 10.CLOSING：两边同时发起关闭请求时，会由FIN_WAIT_1进入此状态。具体动作是接收到FIN请求，同时响应一个ACK。 11.TIME_WAIT：最纠结的状态来了。从状态图上可以看出，有3个状态可以转化成它，我们一一来分析： a.由FIN_WAIT_2进入此状态：在双方不同时发起FIN的情况下，主动关闭的一方在完成自身发起的关闭请求后，接收到被动关闭一方的FIN后进入的状态。 b.由CLOSING状态进入:双方同时发起关闭，都做了发起FIN的请求，同时接收到了FIN并做了ACK的情况下，由CLOSING状态进入。 c.由FIN_WAIT_1状态进入：同时接受到FIN（对方发起），ACK（本身发起的FIN回应），与b的区别在于本身发起的FIN回应的ACK先于对方的FIN请求到达，而b是FIN先到达。这种情况概率最小。 关闭的4次连接最难理解的状态是TIME_WAIT，存在TIME_WAIT的2个理由： 1.可靠地实现TCP全双工连接的终止。 2.允许老的重复分节在网络中消逝。 MAC地址的概念及其作用 MAC地址（MediaAccessControlAddress），媒体访问控制地址，或称为物理地址，是用来定义网络设备的位置的。在OSI模型中，第三层网络层负责IP地址，第二层数据链结层则负责MAC地址。一个主机会有一个IP地址，而每个网络位置会有一个专属于它的MAC地址。 ARP协议的用途及其工作原理 地址解析协议（AddressResolutionProtocol），其基本功能为通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。 在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的，如下表所示。 主机名称 IP地址 MAC地址 A 192.168.38.10 00-AA-00-62-D2-02 B 192.168.38.11 00-BB-00-62-C2-02 C 192.168.38.12 00-CC-00-62-C2-02 D 192.168.38.13 00-DD-00-62-C2-02 E 192.168.38.14 00-EE-00-62-C2-02 … … … 以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到了，也就知道了目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可以了；如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARPrequest），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARPresponse）：“192.168.38.11的MAC地址是（00-BB-00-62-C2-02）”。 这样，主机A就知道了主机B的MAC地址，它就可以向主机B发送信息了。同时它还更新了自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可以了。ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。 了解交换机、路由器、网关的概念，并知道各自的用途 1）交换机 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 2）路由器 路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 3）网关 网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和Internet。网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能转送数据包。在主机（又称终端系统，endsystem）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系统，intermediatesystem）只需要到达网际层（Internetlayer），决定路径之后就可以转送。在当时，网关（gateway）与路由器（router）还没有区别。 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IPgateway）。 网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。 对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。 初识路由表 路由表（routingtable）或称路由择域信息库（、RoutingInformationBase），是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。 路由表使用了和利用地图投递包裹相似的思想。只要网络上的一个节点需要发送数据给网络上的另一个节点，它就必须要知道把数据发送到哪。设备不可能直接连接到目的节点，它需要找到另一个方式去发送数据包。在局域网中，节点也不知道如何发送IP包到网关。将数据包发到正确的地址是一个复杂的任务，网关需要记录发送数据包的路径信息。路由表就存储着这样的路径信息，就如地图一样，是一个记录路径信息，并为需要这些信息的节点提供服务的数据库。 如下图所示为一张路由表： 路由表参数说明： Destination：目的网段 mask：子网掩码 interface：到达该目的地的本路由器的出口ip gateway：下一跳路由器入口的ip，路由器通过interface和gateway定义一调到下一个路由器的链路，通常情况下，interface和gateway是同一网段的 metric：跳数，该条路由记录的质量，一般情况下，如果有多条到达相同目的地的路由记录，路由器会采用metric值小的那条路由 MTU 最大传输单元（MaximumTransmissionUnit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。 因特网协议允许IP分片，这样就可以将数据包分成足够小的片段以通过那些最大传输单元小于该数据包原始大小的链路了。这一分片过程发生在网络层（OSI模型的第三层），第四层为传输层，传输层是OSI模型中最重要的一层，这里是根据窗口控制传输，而非MTU。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。 除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1500字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组，该过程即被称为排序。它使用的是将分组发送到链路上的网络接口的最大传输单元的值。 以太网MTU值为1500字节。 RIP、OSPF、BGP认识 路由信息协议（RoutingInformationProtocol，RIP）是一种使用最广泛的内部网关协议（IGP）。（IGP）是在内部网络上使用的路由协议(在少数情形下,也可以用于连接到因特网的网络)，它可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等，RIP属于网络层。 开放式最短路径优先（OpenShortestPathFirst，OSPF）是对链路状态路由协议的一种实现，是大中型网络上使用最为广泛的IGP（InteriorGatewayProtocol）协议，运作于自治系统内部。著名的迪克斯加算法被用来计算最短路径树。它使用“代价（Cost）”作为路由度量。链路状态数据库（LSDB）用来保存当前网络拓扑结构，它在同一区域中的所有路由器上是相同的。 BGP（边界网关协议，BorderGatewayProtocol）是自治系统之间的路由选择协议，是互联网上一个核心的去中心化自治路由协议。 BGP是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。BGP构建在EGP的经验之上。BGP系统的主要功能是和其他的BGP系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了AS互联的拓朴图并由此清除了路由环路，同时在AS级别上可实施策略决策。 DNS DNS（DomainNameSystem，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 TCP、UDP和HTTP区别于联系 TCP/IP协议是一个协议簇，这个协议簇中包含了很多种协议，TCP、UDP和HTTP只是TCP/IP协议簇的成员。之所以命名为TCP/IP协议，因为TCP,IP协议是两个很重要的协议，就用他两命名了。 1)TCP/IP协议簇，大致可分为三个层次：网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。 HTTP也是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 2）HTTP协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。 HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。一次TCP链接的建立将需要3次握手。 另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此HTTP/1.1提出了可持续链接的实现方法。HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。 3）虽然HTTP本身是一个协议，但其最终还是基于TCP的。目前，有人正在研究基于TCP+UDP混合的HTTP协议。 在浏览器中输入一个网站后，都发生了什么 详细参见：互联网协议入门（二） 以上讲述了一些计算机网络相关的术语，概念，当然，一切才刚刚开始。 如果，你需要了解更多。我可以很负责任的告诉你：以下链接是你更深入的了解计算机网络工作机制的最佳资源，是被奉为圣经的《TCP-IP详解-卷I》一书的精华内容，出自vamei君。 TCP-IP协议详解(1)邮差与邮局 (网络协议概观) TCP-IP协议详解(2) 小喇叭开始广播 (以太网与WiFi协议) TCP-IP协议详解(3) IP接力赛(IP, ARP, RIP和BGP协议) TCP-IP协议详解(4)地址耗尽危机(IPv4与IPv6地址) TCP-IP协议详解(5) 我尽力(IP协议详解) TCP-IP协议详解(6) 瑞士军刀 (ICMP协议) TCP-IP协议详解(7) 傀儡(UDP协议) TCP-IP协议详解(8) 不放弃 (TCP协议与流通信) TCP-IP协议详解(9) 爱的传声筒(TCP连接) TCP-IP协议详解(10) 魔鬼细节 (TCP滑窗管理) TCP-IP协议详解(11) 涅槃 (TCP重新发送) TCP-IP协议详解(12) 天下为公(TCP堵塞控制) TCP-IP协议详解(13) 9527(DNS协议) TCP-IP协议详解(14) 逆袭(CIDR与NAT) TCP-IP协议详解(15) 先生，要点单吗?(HTTP协议概览) 如果上述文章的知识都有所了解，那么原理性的东西我们差不多都似懂非懂了。接下来，我们需要的是实战。恩，接下来实现一下如下的网络程序吧。 1、实现一个简单的一问一答的服务器/客户机模型。 2、用多进程/线程的方式实现一个服务器同时为多个客户端服务的程序(阻塞式的网络程序)。 3、实现一个基于事件驱动的服务器网络程序(如Linux epoll)(异步非阻塞网络程序)。 如果以上事情都做完了，接下来，精彩继续！在Nginx风靡全球之际，每个人都难免好奇，去一探究竟。下面是几个相当好的学习Nginx的精华文章汇总！ Nginx学习资源汇总 最后，计算机网络相关的两篇不该错过的好文章： TCP 的那些事儿（上） TCP 的那些事儿（下）]]></content>
      <categories>
        <category>计算机网络相关</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在pycharm中如何将django中多个app放到同个文件夹apps处理]]></title>
    <url>%2Fposts%2Fab3d95d5%2F</url>
    <content type="text"><![CDATA[新建apps文件夹后mark为source目录，然后在Setting中import方式为 from message import views 但这样run manage.py task时会报模块不存在的错误 ImportError: No module named message 此时要在Setting中设置app的路径 sys.path.insert(0,os.path.joinBASE_DIR,&#39;apps&#39;)) 注意：此时的from message import views必须写在设置路径语句之后还有记得要注册app哦:)]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Web框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python2.7无法pip mysql-python的问题]]></title>
    <url>%2Fposts%2Fcb0b0c45%2F</url>
    <content type="text"><![CDATA[出现问题： &gt; pip install MySQL-python _mysql.c(42) : fatal error C1083: Cannot open include file: &#39;config-win.h&#39;: No such file or directory error: command &#39;&quot;C:\Users\fnngj\AppData\Local\Programs\Common\Microsoft\Visual C ++ for Python\9.0\VC\Bin\amd64\cl.exe&quot;&#39; failed with exit status 2 解决方法：在http://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python下载对应的包版本。然后在命令行执行 pip install MySQL_python-1.2.5-cp27-none-win_amd64.whl]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>python2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualenv各python版本的虚拟环境创建及常用命令说明]]></title>
    <url>%2Fposts%2F824ac3d0%2F</url>
    <content type="text"><![CDATA[win系统首先 pip install virtualenvwrapper-win 创建py2环境 mkvirtualenv -p C:\python27\python.exe(解释器绝对路径) py2env(虚拟环境名) 创建py3环境 mkvirtualenv -p C:\python34\python.exe(解释器绝对路径) py3env(虚拟环境名) linux系统首先也是一样安装virtualenv pip install virtualenvwrapper 然后确定系统中Python的安装位置，比如我的位置在/usr/bin/下创建py2环境 virtualenv -p /usr/bin/python2 py2env 创建py3环境 virtualenv -p /usr/bin/python3 py3env]]></content>
      <categories>
        <category>python学习心得&amp;备忘</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu VPS一键搭建SS]]></title>
    <url>%2Fposts%2F7512e895%2F</url>
    <content type="text"><![CDATA[此脚本具有以下特色：一键安装Shadowsocks集成速锐自定义设置端口设备数量一键添加多端口用户并设置带宽上限一键单端口、多端口切换支持定时重启Shadowsocks一键安装 BBR支持 一键封禁 垃圾邮件(SMAP)/BT/PT 复制命令下载并安装SS脚本 wget -N --no-check-certificate https://softs.fun/Bash/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh]]></content>
      <categories>
        <category>服务器相关问题&amp;备忘</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下搭建环境+安装wordpress]]></title>
    <url>%2Fposts%2Fa6e1042e%2F</url>
    <content type="text"><![CDATA[LAMP 是Linux, Apache, MySQL, PHP, perl的缩写. 指在linux上安装Apache2，MySQL, PHP等软件包所建立的网站运行平台，是目前中小网站主要的运行环境。 1.1 安装Apache2 sudo apt-get install apache21.2 安装MySQL5 sudo apt-get install mysql-server mysql-client中途需要设置root密码 1.3 安装PHP5 sudo apt-get install php5 libapache2-mod-php5 php5-mysql php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl php5-xcache libssh2-php 1.4 安装phpMyAdmin sudo apt-get install phpmyadmin ... Web server to reconfigure automatically: &lt; -- apache2 Configure database for phpmyadmin with dbconfig-common? &lt;-- No ... 2.0 初始化数据库 sudo mysql -u root -p Enter Password: ... mysql&gt; CREATE DATABASE wordpressdb; mysql&gt; CREATE USER wordpressuser@localhost IDENTIFIED BY &#39;你的密码&#39;; mysql&gt; GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost; mysql&gt; FLUSH PRIVILEGES; mysql&gt; exit 重启服务 sudo service apache2 restart sudo service mysql restart 3.0 下载并配置WordPress $ mkdir temp $ cd temp $ wget http://wordpress.org/wordpress-4.x.tar.gz（最新版本号) $ tar zxf wordpress-4.x.tar.gz -C /var/www/html/ $ mkdir -p /var/www/html/wordpress/wp-content/uploads 转自http://www.cnblogs.com/R0b1n/p/5224070.htmlhttp://blog.csdn.net/ansencumt/article/details/9000436目前配置wp-config.php]]></content>
      <categories>
        <category>服务器相关问题&amp;备忘</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>

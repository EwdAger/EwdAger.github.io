---
title: 数据结构题目总结(C 语言描述)
tags:
  - 数据结构
categories: 知识储备
abbrlink: aa2472f4
date: 2018-11-09 20:00:00
---
<blockquote class="blockquote-center">~正文隐藏~</blockquote>
<!-- more -->
# 2007 年

## *完成排序的归并算法

```C
template<class T> void merge(T* a, int n1, int n2){
	//将数组 a 中下标分别从 0...n1-1 和 n1...n1+n2-1 的两个有序序列归并为一个有序序列

	T* temp = new T(n1 + n2);
	int i = 0, j1 = 0, j2 = 0;
	while (j1<n1 & j2<n2)
		temp[i++] = (a[j1] <= a[n1+j2] ? a[j1++] : a[n1+j2++]);
	while (j1<n1)
		temp[j++] = a[j1++];
	while (j2<n2)
		temp[j++] = a[n1+j2++];
	for (int i=0; i<n1+n2; i++)
		a[i] = temp[i];
	delete[]temp;
}

template<class T> void sort(T* a, int n){
	if (n>1){
		int n1 = n / 2;
		int n2 = n - n1;
		sort(a, n1);         // 递归使 a 中前 n1 个元素有序
		sort(a+n1, n2);      // 递归使 a 中后 n2 个元素有序
		merge(a, n1, n2);
	}
}
```

[归并排序图解请点击此处](https://www.cnblogs.com/chengxiao/p/6194356.html)

## *试完成求最短路径的 `Dijkstra` 算法

```C
void ShortestPath_DU(MGaph G, int v0, PathMatrix & P, ShortPathTable & D){
	// 用 dijkstra 算法求有向图 G 的 v0 顶点到其余顶点 v 的最短路径 P[v] 及其带权长度 D[v]
	// 若 P[v][w] 为 True 则 w 是从 v0 到 v 当前求得最短路径上的顶点
	// final[v] 为 True 当且仅当 v∈S，即已经求得 v0 到 v 的最短路径

	int i=0, j, v, w, min;
	bool final[MAX_VERTEX_NUM];
	for (v=0; v<G.vexnum; ++v){
		final[v] = FALSE;
		D[v] = G.arcs[v0][v].adj;
		for (w=0; w<G.vexnum; ++w)
			P[v][w] = FALSE;          // 设空路径
		if (D[v] < INFINITY){
			P[v][v0] = TRUE;
			p[v][v] = TRUE;
		}
	}
	// 初始化， v0 顶点属于 S 集
	D[v0] = 0;
	final[v0] = TRUE;

	// 开始主循环，每次求得 v0 到某个 v 顶点的最短路径，并加 v 到 S 集合

	for (i=1; i<G.vexnum; i++){ //其余 G.vexnum-1 个顶点
		min = INFINITY;        // 当前所知离 v0 顶点的最短距离
		for (w=0; w<G.vexnum; w++)
			if (!final[w]) // w 顶点在 V-S 中
				if (D[w]<min){ // 顶点离 v0 顶点更加
					v = w;
					min = D[w];
				}
		final[v] = TRUE; // 离 v0 顶点最近的 v 添加 S 集
		for (w=0; i<G.vexnum; w++)   // 更新当前最短路径及距离
			if (!final[w] && (min+G.arcs[v][w].adj < D[w])){
				// 修改 D[w] 和 P[w], w∈V-S
				D[w] = min + G.arcs[v][w].adj;
				for (j=0; j<G.vexnum; j++)
					p[w][j] = P[v][j];    // 第 v 行赋值于第 w 行
				p[w][w] = TRUE;
			}
	}
}
```

## *若找到指定结点，将该节点与其前驱结点交换，使得经常被查找的结点尽量位于前端，试设计线性表的顺序存储结构和链式存储结构。并写出上面策略的顺从查找算法。

```c
int search_seq(SSTable ST, KeyType key){
	// 在顺序表中查找关键字等于 key 的数据元素
	// 若找到，则将该元素与其前驱交换（若存在），并返回其在表中的位置（交换后），否则为-1

	for (int i=0; i<ST.length; i++){
		if (key == ST.elem[i]){     // 找到 key 数据元素
			if (i>0){     // 存在前驱，交换
				ElemType temp = ST.elem[i];
				ST.elem[i] = ST.elem[i-1];
				ST.elem[i-1] = temp;
				return i-1;
			}
			else{    // 不存在前驱
				return 0
			}
		}
	}
	return -1
}

LinkNode* search_seq2(LinkList L, KeyType key){
	// 在链表中 L（带头结点）查找关键字等于 key 的数据元素
	// 若找到，则将该元素与其前驱交换（若存在），并返回其在表中的位置（交换后），否则为 NULL

	LinkNode* p = L->next, pre = L;
	while (p != NULL){
		if (key == p->data){   // 找到 key 数据元素
			if (pre != L){    // 存在前驱，交换
				ElemType temp = pre->data;
				pre->data = p->data;
				p->data = temp;
				return pre;
			}
			else{      // 不存在前驱
				return p;
			}
		}
	}
	return NULL;
}
```

# 2008 年

## *编写递归算法，统计并返回以 `BT` 为树根指针的二叉树叶子结点个数

```c
// 采用先序遍历整棵二叉树，统计叶子结点个数
int count = 0;
void Count(BTreeNode* BT){
    if (BT!=NULL){
        if (BT->lchild == NULL && BT->rchild == NULL)
            count++;
        Count(BT->lchild);
        Count(BT->rchild);
    }
}
```

## *编写以 `BST` 为树根指针的二叉搜索树上进行查找值为 `Item` 的结点的非递归算法

```c
// 根据 item 的值和当前节点的比较，如果相等就找到返回，如果小于，当前节点移动到右孩子，否则移动找左孩子，重复上述过程。如果最后没有找到，返回 false

bool Find(BTreeNode* BST, ElemType &item){
    BTreeNode* p = BST;
    while(!p){
        if (item == p->data){
            item = p->data;
            return TRUE;
        }
        else if (item < p->data)
            p = p->left;
        else
            p = p->right;
    }
    return FALSE;
}
```

# 2009 年

## *设计在顺序有序表中实现二分查找的算法

```c
int BinarySearch(SeqList L, ElemType key){
    // 在有序表 L 中查找关键字为 key 的元素，若存在则返回位置，不存在则返回-1
    int low = 0, high = L.TableLen-1, mid;
    while (low <= high){
        mid = (low + high) / 2;     // 取中间位置
        if (L.elem[mid] == key)     // 查找成功返回所在位置
            return mid;
        else if (L.elem[mid] > key)  // 从前半部分查找
            high = mid - 1;
        else
            low = mid + 1;

    }
    return -1
}
```

## 编写一个算法作为将线性表 `L` 的数据建立一棵二叉排序树

```c
int BST_Insert(BiTree &T, KeyType k){
    // 在二叉排序树 T 中插入一个关键字 k 的节点
    if (T == NULL){                         // 原树为空，新插入的记录为根节点
        T = (BiTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild = T->rchild = NULL;
        return 1                            // 返回 1，表示树空间申请成功，并建立根节点
    }
    else if (k == T->key)                  // 树中存在相同的关键字节点，跳过该节点
    else if (k < T->key)
        return BST_Insert(T->lchild, k);   // 插入到 T 的左子树
    else
        return BST_Insert(T->rchild, k);  // 插入到 T 的右子树
}

void Create_BST(BiTree &T, KeyType L[], int n){
    // 用长度为 n 的线性表建立一个二叉排序树
    T = NULL;          // 初始化 T 为空
    for (int i=0; i<n; i++)
        BST_Insert(T, L[i]);
}
```

## 带头结点的单链表中，所有节点值递增排序，编写函数。删除表 `L` 中所有其值大于等于 `min` 小于等于`max` 的结点

```c
void rangeDelete(LinkList & L, ElemType min, ElemType max){
    // q 初始化指向待处理链表的头结点指针，而p始终为下一节点指针
    // 如果 q 的下一节点（p）不在min-max范围内，则将 q 的下一节点变为下下一节点(p->next)
    ListNode* q = L, *p = L->next;
    while (p!=NULL){
        if (p->data >= min && p->data <= max){  // 需要删除
            q->next = p->next;                  // 将 q 的下一节点取代为下下一节点
            free(p);                            // 清理下一节点的空间
            p = q->next                         // 重置 p 为删除后链表 L 的下一节点
        }
        else{
            q = p;             // 同等于 q = q->next;
            p = p->next;
        }
    }
}
```

## *写出求 `DFS` 生成树（生成森林）的算法，并打印所有的树边

```c
int visited[MAXNUM]; // 访问标致数组
void DFSTraverseTree (ALGraph *G){
    // 求深度优先生成树（以邻接表表示的图 G)
    for (int i=0; i<n; i++)
        visited[i] = FALSE;      // 初始化访问标志数组
    for (int i=0; i<n; i++)
        if (!visited[i])       // 第 i 个结点没有访问过
            DFSTree(G, i);    // 以 vi 为源点开始 DFS 遍历 G
}

void DFSTree (ALGraph* G, int i){
    // 以 vi 为出发点对邻接表表示的图 G 进行深度优先搜索，打印出生成树的边
    EdgeNode *p;
    visited[i] = TRUE;   // 标记 vi 已访问
    p = G->adjlist[i].firstEdge;     // 取 vi 边表的头指针
    while(p){
        // 依次搜索 vi 的邻接点vj， 这里 j=p->adjvex;
        if (!visited[p->adjvex]){   // 若 vj 尚未被访问
            // 打印边
            printf("(%c, %c)\n", G.vertex[i]->adjlist, G.vertex[p->adjvex]-adjlist);
            DFSTree(G, p->adjvex);
        }
        p = p->next;
    }
}
```

# 2010 年

## 线性表插入删除一个结点

```c
bool ListInsert(Sqlist &L, int i, ElemType e){
    // 本算法实现将元素 e 插入到顺序表 L 中第 i 个位置
    if (i<1 || i>L.length+1) // 判断 i 的范围是否有效
        return FALSE;
    if (L.length >= MaxSize)  //当前存储空间已满，不能插入
        return FALSE;
    for (int j=L.length; j>=i; j--)  // 将第 i 个元素及之后的元素后移
        L.data[j] = L.data[j-1];
    L.data[i-1] = e;         // 在位置 i 处放入 e
    L.length++;
    return TRUE;
}

bool ListDelete(Sqlist &L, int i, int &e){
    // 本算法实现删除顺序表 L 中第 i 个位置的元素
    if (i<1 || i>L.length)   // 判断 i 的范围是否有效
        return FALSE;
    e = L.data[i-1];         // 在位置 i 处放入 e
    for (int j=i; j<L.length; j++)   // 将第 i 个位置之后的元素前移
        L.data[j-1] = L.data[j];
    L.length--;
    return TRUE;
}
```

## *二叉排序树采用二叉链表存储，删除结点值 `X` 的结点。删除后仍为二叉排序树（不考虑 `X`为根）

思路：先用层次遍历思想查找到值为 X 的结点， 然后根据其是否有左右孩子情况删除处理。如果无左孩子，直接将右子树代替它。同理如果没有右孩子，直接将左子树代替它。如果左右孩子都存在，边在左子树中找一个值最大的结点代替它。
```c
int DeleteBST (BiTree &T, ElemType X){
    // 删除二叉排序树 T 中，结点值为 X 的结点
    if (!T)
        return 0;  //不存在这样的结点
    else{
        if (X==T.key)
            return Delete(T);
        else if (X<T.key)
            return DeleteBST(T->lchild, X);
        else
            return DeleteBST(T->rchild, X);
    }
}

int Delete(BiTree & p){
    // 从二叉树排序树中删除结点 p，并且重接他的左或右子树
    if (!p->rchild){   // 右子树为空，只需重接左子树
        q = p;
        p = p->lchild;
        free(q);
    }
    else if (!p->rchild){  // 左子树为空，只需要重接右子树
        q = p;
        p = p->rchild;
        free(q);
    }
    else{    // 左右子树均不空
        q = p;
        s = p->lchild;
        while (s->rchild){   // 找到左子树中结点值最大的结点 s
            q = s;
            s = s->rchild;
        }
        p->key = s->key;
        if (q != p)
            q->rchild = s->lchild;
        else
            q->lchild = s->lchild;
        free(s);
    }
    return 1;
}
```

## *设 `X` 和 `Y` 是表示成单链表的两个串，找出 `X` 中第一个不在 `Y` 中出现的字符

采用带头结点的单链表作为串的存储结构，找出 X 中第一个不在 Y 中出现的结点的算法
```c
char find(LinkList X, LinkList Y){
    LNode* p = X->next, *q;
    while(p){
        // 遍历 Y，查找是否存在值为 p->data 的结点
        q = Y->next;
        while(q){
            if (p->data == q->data)
                break;
            else
                q = q->next;
        }
        if (!q)
            return p->data;  // Y 中没有找到
        else
            p = p->next;   // Y 中找到，继续查找下一个元素
    }
}
```

# 2011 年

## 求带头结点的单链表 `L` 中所含元素的个数，并给出单链表的数据结构示意图

```c
int CountNode(LinkList L){
    int count = 0;
    LNode * p = L->next;
    while(p){
        count++;
        p = p->next;
    }
    return count;
}

# 示意图：
#
# A->B->C...->N
```

## 递归函数求二叉树的高度

```c
int Height(BiTree T){
    if (T == NULL)
        return 0;
    int ld = Height(T->lc);
    int rd = Height(T->rc);
    return (ld>rd ? ld+1 : rd+1);
}
```

# 2012 年

## *对一棵孩子 - 兄弟链表示的树统计其叶子的个数

思路：采用还在兄弟链表示的树 T，对其从所有结点进行遍历。在访问结点是判定当前结点是否有孩子，如果没有孩子则该结点是叶子结点，计数器加一，遍历结束后，就能得到叶子结点数。
```c

```

## *查找值为 `X` 的结点（二叉树中）。用 C 语言打印值为 `X` 的结点的所有祖先并分析时间复杂度

## *`L1`、`L2`为两循环单链表的头结点指针。`m`，`n`分别为数据结点个数。用最快速度将两表并成一个带头结点的循环单链表

TODO

## *求无向图 `G` （采用邻接表存储）的连通分量的个数

TODO

# 2013 年

## *给定二叉树 `T` 。统计二叉树 `T` 中结点的个数

TODO

## *给定图 `G = （V, E)` 设计算法统计图 `G` 中连通块的个数

TODO

# 2014 年

## *线性表`（a1, a2, … , an）`设计把所有偶数移动所有奇数前面。（时间最少，辅助空间最多）

TODO

## *求二叉树中以权值为 `X` 的 结点为根的子树的深度

# 2015 年

## *判断二叉树是否为二叉排序树

TODO

## *将无向图邻接矩阵转为对应的邻接表的算法

TODO

## *给定图 `G = (V, E)` 其中 `G` 包含 `n` 个点和 `m` 条边。统计 `G` 中连通块分量的个数

TODO

# 2016 年

## *线性表元素递增，单链表存储。删除表中有值相同的多余元素并释放空间

TODO

## *算法判别给定表达式中开括号是否配对出现

TODO

## *给定二叉树 `T` 设计算法复制二叉树 `T`

TODO

## *给图 ` G = (V, E)` 和 `G` 中两个顶点 `S`, `T` 求一条顶点 `t` 到顶点 `S` 的简单路径

TODO

# 2017 年

## *中序遍历二叉树 `T` (非递归)

TODO

## *给定两个非空集合 `A` 和 `B` 分别用线性表 `L1` 和 `L2` 存储。算法求解 A∪B

TODO

## *给定表达式 `A + B * C - D | E` 后缀表达式为 `ABC *+ DE /-` 设计算法将原表达式转为为后缀表达式

TODO

## *给定两棵树 `T1` 和 `T2` 判断 `T1` 与 `T2` 是否相同（二叉树）

TODO

# 2018 年

## *计算两个多项式乘积（给定 `La`、`Lb` 两个带头结点单链表表示的多项式）

TODO

## *给定二叉树，以先序形式输出所有结点的值和结点所在层次

TODO
---
title: 数据结构题目总结(C 语言描述)
tags:
  - 数据结构
categories: 知识储备
abbrlink: aa2472f4
date: 2018-11-09 20:00:00
---
<blockquote class="blockquote-center">~正文隐藏~</blockquote>
<!-- more -->
# 2007 年

##  **完成排序的归并算法**

```C
template<class T> void merge(T* a, int n1, int n2){
	//将数组 a 中下标分别从 0...n1-1 和 n1...n1+n2-1 的两个有序序列归并为一个有序序列

	T* temp = new T(n1 + n2);
	int i = 0, j1 = 0, j2 = 0;
	while (j1<n1 & j2<n2)
		temp[i++] = (a[j1] <= a[n1+j2] ? a[j1++] : a[n1+j2++]);
	while (j1<n1)
		temp[j++] = a[j1++];
	while (j2<n2)
		temp[j++] = a[n1+j2++];
	for (i=0; i<n1+n2; i++)
		a[i] = temp[i];
	delete[]temp;
}

template<class T> void sort(T* a, int n){
	if (n>1){
		int n1 = n / 2;
		int n2 = n - n1;
		sort(a, n1);         // 递归使 a 中前 n1 个元素有序
		sort(a+n1, n2);      // 递归使 a 中后 n2 个元素有序
		merge(a, n1, n2);
	}
}
```

[归并排序图解请点击此处](https://www.cnblogs.com/chengxiao/p/6194356.html)

## 试完成求最短路径的 `Dijkstra` 算法

```C
void ShortestPath_DU(MGaph G, int v0, PathMatrix & P, ShortPathTable & D){
	// 用 dijkstra 算法求有向图 G 的 v0 顶点到其余顶点 v 的最短路径 P[v] 及其带权长度 D[v]
	// 若 P[v][w] 为 True 则 w 是从 v0 到 v 当前求得最短路径上的顶点
	// final[v] 为 True 当且仅当 v∈S，即已经求得 v0 到 v 的最短路径

	int i=0, j, v, w, min;
	bool final[MAX_VERTEX_NUM];
	for (v=0; v<G.vexnum; ++v){
		final[v] = FALSE;
		D[v] = G.arcs[v0][v].adj;
		for (w=0; w<G.vexnum; ++w)
			P[v][w] = FALSE;          // 设空路径
		if (D[v] < INFINITY){
			P[v][v0] = TRUE;
			p[v][v] = TRUE;
		}
	}
	// 初始化， v0 顶点属于 S 集
	D[v0] = 0;
	final[v0] = TRUE;

	// 开始主循环，每次求得 v0 到某个 v 顶点的最短路径，并加 v 到 S 集合

	for (i=1; i<G.vexnum; i++){ //其余 G.vexnum-1 个顶点
		min = INFINITY;        // 当前所知离 v0 顶点的最短距离
		for (w=0; w<G.vexnum; w++)
			if (!final[w]) // w 顶点在 V-S 中
				if (D[w]<min){ // 顶点离 v0 顶点更加
					v = w;
					min = D[w];
				}
		final[v] = TRUE; // 离 v0 顶点最近的 v 添加 S 集
		for (w=0; i<G.vexnum; w++)   // 更新当前最短路径及距离
			if (!final[w] && (min+G.arcs[v][w].adj < D[w])){
				// 修改 D[w] 和 P[w], w∈V-S
				D[w] = min + G.arcs[v][w].adj;
				for (j=0; j<G.vexnum; j++)
					p[w][j] = P[v][j];    // 第 v 行赋值于第 w 行
				p[w][w] = TRUE;
			}
	}
}
```

## 若找到指定结点，将该节点与其前驱结点交换，使得经常被查找的结点尽量位于前端，试设计线性表的顺序存储结构和链式存储结构。并写出上面策略的顺从查找算法。

```c
int search_seq(SSTable ST, KeyType key){
	// 在顺序表中查找关键字等于 key 的数据元素
	// 若找到，则将该元素与其前驱交换（若存在），并返回其在表中的位置（交换后），否则为-1

	for (int i=0; i<ST.length; i++){
		if (key == ST.elem[i]){     // 找到 key 数据元素
			if (i>0){     // 存在前驱，交换
				ElemType temp = ST.elem[i];
				ST.elem[i] = ST.elem[i-1];
				ST.elem[i-1] = temp;
				return i-1;
			}
			else{    // 不存在前驱
				return 0
			}
		}
	}
	return -1
}

LinkNode* search_seq2(LinkList L, KeyType key){
	// 在链表中 L（带头结点）查找关键字等于 key 的数据元素
	// 若找到，则将该元素与其前驱交换（若存在），并返回其在表中的位置（交换后），否则为 NULL

	LinkNode* p = L->next, pre = L;
	while (p != NULL){
		if (key == p->data){   // 找到 key 数据元素
			if (pre != L){    // 存在前驱，交换
				ElemType temp = pre->data;
				pre->data = p->data;
				p->data = temp;
				return pre;
			}
			else{      // 不存在前驱
				return p;
			}
		}
	}
	return NULL;
}
```

# 2008 年

## 编写递归算法，统计并返回以 `BT` 为树根指针的二叉树叶子结点个数

TODO

## 编写以 `BST` 为树根指针的二叉搜索树上进行查找值为 `Item` 的结点的非递归算法

TODO

# 2009 年

## 设计在顺序有序表中实现二分查找的算法

TODO

## 编写一个算法作为将线性表 `L` 的数据建立一棵二叉排序树

TODO

## 带头结点的单链表中，所有节点值递增排序，编写函数。删除表 `L` 中所有其值大于等于 `min` 小于等于`max` 的结点

TODO

## 写出求 `DFS` 生成树（生成森林）的算法，并打印所有的树边

TODO

# 2010 年

## 线性表插入删除一个结点

TODO

## 二叉排序树采用二叉链表存储，删除结点值 `X` 的结点。删除后仍为二叉排序树（不考虑 `X`为根）

TODO

## 设 `X` 和 `Y` 是表示成单链表的两个串，找出 `X` 中第一个不在 `Y` 中出现的字符

TODO

## 给定一个用链表表示的二叉树，写出求叶子数目的算法 

TODO

# 2011 年

## 求带头结点的单链表 `L` 中所含元素的个数，并给出单链表的数据结构示意图

TODO

## 递归函数求二叉树的高度

TODO

## 折半查找算法

TODO

# 2012 年

## 对一棵孩子 - 兄弟链表示的树统计其叶子的个数

TODO

## 查找值为 `X` 的结点（二叉树中）。用 C 语言打印值为 `X` 的结点的所有祖先并分析时间复杂度

## `L1`、`L2`为两循环单链表的头结点指针。`m`，`n`分别为数据结点个数。用最快速度将两表并成一个带头结点的循环单链表

TODO

## 求无向图 `G` （采用邻接表存储）的连通分量的个数

TODO

# 2013 年

## 给定二叉树 `T` 。统计二叉树 `T` 中结点的个数

TODO

## 给定图 `G = （V, E)` 设计算法统计图 `G` 中连通块的个数

TODO

# 2014 年

## 线性表`（a1, a2, … , an）`设计把所有偶数移动所有奇数前面。（时间最少，辅助空间最多）

TODO

## 求二叉树中以权值为 `X` 的 结点为根的子树的深度

# 2015 年

## 判断二叉树是否为二叉排序树

TODO

## 将无向图邻接矩阵转为对应的邻接表的算法

TODO

## 给定图 `G = (V, E)` 其中 `G` 包含 `n` 个点和 `m` 条边。统计 `G` 中连通块分量的个数

TODO

# 2016 年

## 线性表元素递增，单链表存储。删除表中有值相同的多余元素并释放空间

TODO

## 算法判别给定表达式中开括号是否配对出现

TODO

## 给定二叉树 `T` 设计算法复制二叉树 `T`

TODO

## 给图 ` G = (V, E)` 和 `G` 中两个顶点 `S`, `T` 求一条顶点 `t` 到顶点 `S` 的简单路径

TODO

# 2017 年

## 中序遍历二叉树 `T` (非递归)

TODO

## 给定两个非空集合 `A` 和 `B` 分别用线性表 `L1` 和 `L2` 存储。算法求解 A∪B

TODO

## 给定表达式 `A + B * C - D | E` 后缀表达式为 `ABC *+ DE /-` 设计算法将原表达式转为为后缀表达式

TODO

## 给定两棵树 `T1` 和 `T2` 判断 `T1` 与 `T2` 是否相同（二叉树）

TODO

# 2018 年

## 计算两个多项式乘积（给定 `La`、`Lb` 两个带头结点单链表表示的多项式）

TODO

## 给定二叉树，以先序形式输出所有结点的值和结点所在层次

TODO
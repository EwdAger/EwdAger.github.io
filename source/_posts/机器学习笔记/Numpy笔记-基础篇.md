---
title: Numpy 笔记-基础篇
tags:
  - Python
  - Numpy
  - 数据分析
abbrlink: ca37cdbd
categories: 机器学习笔记
date: 2019-08-22 11:17:06
---


# 创建 ndarray
## 常用方法
`array`函数可接受一切序列类型对象
```python
In [2]: data1 = [6.1, 5, 4, 3, 1]

In [3]: arr1 = np.array(data1)

In [4]: arr1
Out[4]: array([6.1, 5, 4, 3, 1])

In [5]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]

In [6]: arr2 = np.array(data2)

In [7]: arr2
Out[7]:
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

In [8]: arr2.shape
Out[8]: (2, 4)

In [9]: arr2.dtype
Out[9]: dtype('int32')
```

除非显式说明，`np.array`会尝试为新建的这个数组判断一个较为合适的数据类型。数据类型保存在特殊的`dtype`对象中。比如上面的两个例子中。我们有：

```python
In [19]: arr1.dtype
Out[19]: dtype('float64')

In [20]: arr2.dtype
Out[20]: dtype('int32')
```

## 其他新建数组方法

函数 | 说明
---- | ----
asarray | 将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制
arange | `np.arange(5) → array([0, 1, 2, 3, 4])`
ones | `np.ones((2,2)) → array([[1., 1.], [1., 1.]])`
ones_like | `np.ones_like([1,2,3]) → array([1, 1, 1])`
zeros | `np.zeros((2,2)) → array([[0., 0.], [0., 0.]])`
zeros_like | `np.ones_like([1,2,3]) → array([0, 0, 0])`
empty、empty_like | `np.empty(1) → array([5.06106712e+58])`
eys、identity | `np.eye(2) → array([[1., 0.], [0., 1.]])`

*`X` 根据指定的形状和dtype创建一个为X的数组， `X_like`以另一个数组为参数，并根据其形状和dtype创建一个为X的数组*

# ndarray 的数据类型

** 调用`astype`会创建一个新的数组，而不是对原数组进行修改**

```python
# 显式说明类型
In [39]: arr1 = np.array([1, 2, 3], dtype=np.float64)

In [40]: arr1
Out[40]: array([1., 2., 3.])

In [41]: arr1.dtype
Out[41]: dtype('float64')

# 修改类型
In [42]: int_arr1 = arr1.astype(np.int64)

In [43]: int_arr1
Out[43]: array([1, 2, 3], dtype=int64)

In [44]: int_arr1.dtype
Out[44]: dtype('int64')

# 另一种修改类型方法
In [45]: int_arr = np.arange(10)

In [47]: float_arr = np.array([.1, .3, .5,.6], dtype=np.float64)

In [48]: int_arr.astype(float_arr.dtype)
Out[48]: array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

```

# 数组和标量之间的运算

FBI WARNING！离！散！数！学！警！告！


```python
In [49]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])

In [50]: arr
Out[50]:
array([[1., 2., 3.],
       [4., 5., 6.]])

In [51]: arr * arr
Out[51]:
array([[ 1.,  4.,  9.],
       [16., 25., 36.]])

In [52]: arr - arr
Out[52]:
array([[0., 0., 0.],
       [0., 0., 0.]])

In [53]: arr + arr
Out[53]:
array([[ 2.,  4.,  6.],
       [ 8., 10., 12.]])

In [54]: arr / arr
Out[54]:
array([[1., 1., 1.],
       [1., 1., 1.]])

In [55]: 1 / arr
Out[55]:
array([[1.        , 0.5       , 0.33333333],
       [0.25      , 0.2       , 0.16666667]])

In [57]: arr ** 0.5
Out[57]:
array([[1.        , 1.41421356, 1.73205081],
       [2.        , 2.23606798, 2.44948974]])

```


# 基本的索引和切片

## 切片的注意事项

**NumPy中将一个标量赋值给切片，会自动修改整个选取！并且将切片赋值给一个变量，修改变量原数组也会改变！如想得到一个副本，需要copy或者deepcopy**


```python
# 切片与修改切片
In [58]: arr = np.arange(10)

In [59]: arr[5]
Out[59]: 5

In [60]: arr[5:8]
Out[60]: array([5, 6, 7])

In [61]: arr[5:8] = 12

In [62]: arr
Out[62]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])

# 赋值变量后修改切片
In [63]: arr_sli = arr[5:8]

In [64]: arr_sli[1] = 1234

In [65]: arr
Out[65]: array([   0,    1,    2,    3,    4,   12, 1234,   12,    8,    9])

In [66]: arr_sli[:] = 64

In [67]: arr
Out[67]: array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])

```
由于 Numpy 是的设计目的是处理大数据，所以坚持将数据复制出来会产生极大的性能和内存问题。

## 高维数组索引

类似Python基本库中的多维列表索引，但Numpy中多维数组可以使用以逗号隔开的索引列表来选取单个元素

```python
In [89]: arr2d
Out[89]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [90]: arr2d[1][1]
Out[90]: 5

# 等价
In [91]: arr2d[1,1]
Out[91]: 5

```

## 切片索引

```python
# 第一项切行，第二项切列

In [92]: arr2d
Out[92]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [93]: arr2d[:2, 1:]
Out[93]:
array([[2, 3],
       [5, 6]])
```

# 布尔索引

布尔型数组的长度必须跟被索引的轴长度一致，并且可以和切片、整数混合使用

```python
In [95]: names
Out[95]: array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')


In [96]: names == 'Bob'
Out[96]: array([ True, False, False,  True, False, False, False])

In [98]: from numpy.random import randn

In [99]: data = randn(7, 4)

In [100]: data
Out[100]:
array([[ 1.0414046 ,  0.27541176, -0.28867275,  0.43976932],
       [ 1.41040224,  0.85299112, -1.25119339, -0.22021196],
       [ 0.6567735 , -1.68611377,  1.21111831,  0.30837087],
       [-1.71472061,  1.83107771, -0.4621784 , -0.44085432],
       [ 1.62355481,  1.05545767,  1.03071674, -0.58314536],
       [ 1.42174078,  0.37195811,  0.33015409, -1.5331736 ],
       [ 0.30902783, -0.65909982, -0.74522413, -0.40299012]])

In [101]: data[names == 'Bob']
Out[101]:
array([[ 1.0414046 ,  0.27541176, -0.28867275,  0.43976932],
       [-1.71472061,  1.83107771, -0.4621784 , -0.44085432]])

# 混合使用

In [102]: data[names=='Bob', 2:]
Out[102]:
array([[-0.28867275,  0.43976932],
       [-0.4621784 , -0.44085432]])

# 否定用法

In [103]: names != 'Bob'
Out[103]: array([False,  True,  True, False,  True,  True,  True])

In [105]: data[~(names=='Bob')]
Out[105]:
array([[ 1.41040224,  0.85299112, -1.25119339, -0.22021196],
       [ 0.6567735 , -1.68611377,  1.21111831,  0.30837087],
       [ 1.62355481,  1.05545767,  1.03071674, -0.58314536],
       [ 1.42174078,  0.37195811,  0.33015409, -1.5331736 ],
       [ 0.30902783, -0.65909982, -0.74522413, -0.40299012]])

# 布尔条件 & | （不可使用 and or）

In [107]: mask = (names == 'Bob') | (names == 'Will')

In [108]: mask
Out[108]: array([ True, False,  True,  True,  True, False, False])

# 布尔索引使用示例

In [110]: data[data<0]=0

In [111]: data
Out[111]:
array([[1.0414046 , 0.27541176, 0.        , 0.43976932],
       [1.41040224, 0.85299112, 0.        , 0.        ],
       [0.6567735 , 0.        , 1.21111831, 0.30837087],
       [0.        , 1.83107771, 0.        , 0.        ],
       [1.62355481, 1.05545767, 1.03071674, 0.        ],
       [1.42174078, 0.37195811, 0.33015409, 0.        ],
       [0.30902783, 0.        , 0.        , 0.        ]])


```

# 花式索引

花式索引和切片不同，他总是将数据复制进新数组

```python
In [114]: arr
Out[114]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

# 取1,5,7,2行区域（形成新数组）
In [115]: arr[[1,5,7,2]]
Out[115]:
array([[ 4,  5,  6,  7],
       [20, 21, 22, 23],
       [28, 29, 30, 31],
       [ 8,  9, 10, 11]])

# 取(1, 0), (5, 3), (7, 1), (2, 2)位置的元素区域
In [116]: arr[[1,5,7,2], [0,3,1,2]]
Out[116]: array([ 4, 23, 29, 10])

# 取1,5,7,2行区域，列按[0,3,1,2]顺序排列
In [117]: arr[[1,5,7,2]][:, [0,3,1,2]]
Out[117]:
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])

# 花式索引是生成新数组

In [122]: arr2 = arr[[1,5,7,2]]

In [123]: arr2
Out[123]:
array([[ 4,  5,  6,  7],
       [20, 21, 22, 23],
       [28, 29, 30, 31],
       [ 8,  9, 10, 11]])

In [124]: arr2 = 1

In [125]: arr
Out[125]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

```

# 数组转置和轴对换

```python
In [127]: arr
Out[127]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [128]: arr.T
Out[128]:
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])


# 看不懂。。
In [130]: arr
Out[130]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [132]: arr.transpose((1,0,2))
Out[132]:
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])

```


# 通用函数：快速的元素级数组函数

通用函数是一种能对ndarray中的数据执行元素级运算的函数。

```python
In [133]: arr = np.arange(10)

# 平方根
In [134]: np.sqrt(arr)
Out[134]:
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

# e为底的指数
In [135]: np.exp(arr)
Out[135]:
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])

# 元素级最大值
In [136]: x = randn(8)

In [137]: y = randn(8)

In [139]: x
Out[139]:
array([ 0.29123626,  2.54672169, -1.0185621 ,  0.46756089, -1.72738298,
        0.73119483, -0.55088788, -0.14345012])

In [140]: y
Out[140]:
array([ 1.53812286,  0.28810153, -0.65714547, -1.07375593,  1.31292609,
        0.5431188 , -0.18918957,  0.30398994])

In [138]: np.maximum(x, y)
Out[138]:
array([ 1.53812286,  2.54672169, -0.65714547,  0.46756089,  1.31292609,
        0.73119483, -0.18918957,  0.30398994])

```

## 一元ufunc

函数 | 说明
----| ----
abs、fabs | 计算整数、浮点数或复数的绝对值。对于非复数值，可以使用fabs更快
sqrt | 平方根
square | 平方
exp | 以e为底的指数
log、log10、log2、log1p | 自然对数、10为底、2为底、log(1+x)
sign | 计算各元素正负号1(正数)0(零)-1(负数)
ceil | 向上取整
floor | 向下取整
rint | 四舍五入，保留dtype
modf | 将小数和整数部分以两个独立数组的形式返回
isnan | 返回是NaN值的布尔数组
isfinite、isinf | 返回是有穷数（非inf、非NaN）、无穷数的布尔数组
cos、cosh、sin、sinh、tan、tanh | 普通、双曲型三角函数
arccos、arccosh、arcsin、arcsinh、arctan、arctanh、 | 反三角函数
logical_not | 各元素not x的真值。相当于-arr

## 二元ufunc

函数 | 说明
--- | ---
add | 对应元素相加
subtract | 从第一个数组中减去第二个数组中的元素
multiply | 数组相乘
divide、floor_divide | 除法、向下圆整除法(丢弃余数)
power | A数组的B次方
maximum、fmax | 最大值、fmax忽略NaN
minimum、fmin | 最小值、fmin忽略NaN
mod | 取模
copysign | 将B数组值的符号复制给第一个数组
greater、greater_equal、less、less_equal、equal、not_equal | 比较运算，生成布尔数组，>、>=、<、<=、==、!=
logical_and、logical_or、logical_xor | 元素级真值逻辑运算，相当于&、&#124; 、^
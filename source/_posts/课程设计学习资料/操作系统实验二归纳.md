---
title: 操作系统实验二归纳
tags:
  - 操作系统
  - 课程设计
categories: 课程设计
abbrlink: 6ee94925
date: 2017-06-13 10:35:10
---

**本实验是要求在linux环境下测试fork()和exec()，并建立一个简单的shell（带cd、env、echo、help、jobs、quit命令）**

- ## fork()

这一节没啥难度，主要是测试当前linux环境下gcc是否能编译成功
```c++
清单 2-1 创建进程
#include <stdio.h>   //此处指导书上没有
int main (){
    int x;
    while((x=fork())==-1);
    if (x==0)
        printf("a");
    else
        printf("b");
printf("c");
}
```
<!-- more -->
这里出现了很奇妙的问题，指导书上没有使用stdio头文件，不过显然这样编译不会通过。但是加上了以后又出现了一个坑，实验室里的linux没有安装gcc的包依赖。此处需要我们重装个gcc
```shell
$ sudo apt-get install build-essential  //此处也许会失败，提示缺少几个依赖，那就安装相应的包
$ sudo apt-get install g++   //上一步如果不行就运行这个再运行上一条
```
*linux下怎么build .c文件也留档一下吧*
` $ gcc -o hello hello.c    // 第一个为生成的文件名，第二个为.c文件 `

- ## exec()

这真是一个骚操作。可以直接用新的进程映象置换当前的进程映象，留档函数原型
> exec 系列有 6 个函数，原型如下：
extern char **environ;
int execl( const char *path, const char *arg, ...);
int execlp( const char *file, const char *arg, ...);
int execle( const char *path, const char *arg , ..., char * const envp[]);
int execv( const char *path, char *const argv[]);
int execve (const char *filename, char *const argv [], char *const envp[]);
int execvp( const char *file, char *const argv[]);
exec 系列函数用新的进程映象置换当前的进程映象.这些函数的第一个参数是待执行程序的路
径名(文件名)。这些函数调用成功后不会返回,其进程的正文(text),数据(data)和栈(stack)段被待执行
程序程序覆盖。但是进程的 PID 和所有打开的文件描述符没有改变,同时悬挂信号被清除，信号重
置为缺省行为。
在函数 execl,execlp,和 execle 中, const char *arg 以及省略号代表的参数可被视为 arg0,
arg1, ...,argn。它们合起来描述了指向 NULL 结尾的字符串的指针列表，即执行程序的参数列表。作
为约定,第一个 arg 参数应该指向执行程序名自身,参数列表必须用 NULL 指针结束。
execv 和 execvp 函数提供指向 NULL 结尾的字符串的指针数组作为新程序的参数列表。作为约
定，指针数组中第一个元素应该指向执行程序名自身。指针数组必须用 NULL 指针结束。
execle 函数同时说明了执行进程的环境(environment),它在 NULL 指针后面要求一个附加参
数,NULL 指针用于结束参数列表,或者说,argv 数组。这个附加参数是指向 NULL 结尾的字符串的指
针数组,它必须用 NULL 指针结束。其它函数从当前进程的 environ 外部变量中获取新进程的环境。
execlp和execvp可根据path搜索合适的程序运行，其它则需要给出程序全路径。
execve（）类似 execv（），但是加上了环境的处理。

在把此处的示例程序解释一下吧：
```c++
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
int main(){
        pid_t pid;
        /* fork a child process */
        pid = fork();
        if (pid < 0){
        /* error occurred */
                fprintf(stderr, "Fork Failed");
                return 1;
        }
        else if (pid == 0){ 
        /* 子进程 */
        execlp("/bin/ls","ls",NULL);
        }
        else { /* 父进程 */
        / * 父进程将一直等待，直到子进程运行完毕*/
        wait(NULL);
        printf("Child Complete");
        }
return 0;
}
```
我的理解是这份代码的意思应该是，创建一个进程，如果该进程的pid<0（当然创建fork成功会返回大于0的数）提示fork失败。然后再使用execlp调用系统中的ls命令，运行结果图

![EwdAger](http://upload-images.jianshu.io/upload_images/5433252-d73e30909e8345ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- ##简单的shell

```c++
#include <sys/types.h>
#include <sys/wait.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

char op[256];
char arg[256];
char str[1024];

int main()
{
    pid_t CurSon;

    while(1){
        scanf("%s", op);
        if(strcmp(op, "quit") == 0 || strcmp(op, "exit") == 0 || strcmp(op, "bye") == 0){
            printf("\nQuiting...Bye~");
            return 0;
        }else if(strcmp(op, "help") == 0){
            printf("It's a fake shell~\n");
        }else if(strcmp(op, "cd") == 0){
            scanf("%s", arg);
            sprintf(str, "cd %s", arg);
            system(str);
        }else if(strcmp(op, "environ") == 0){
            system("env");
        }else if(strcmp(op, "echo") == 0){
            scanf("%s", arg);
            sprintf(str, "echo %s", arg);
            system(str);
        }else if(strcmp(op, "jobs") == 0){
            system("ps");
        }else{
        	fgets(arg, 256, stdin);
        	sprintf(str, "%s %s", op, arg);
        	while((CurSon = fork()) < 0);
        	if(CurSon == 0){
            	system(str);
            	return 0;
        	}else{
            	wait(NULL);
            	printf("%s\n", str);
            	printf("Complete...\n");
        	}
        }
    }
    return 0;
}
```
